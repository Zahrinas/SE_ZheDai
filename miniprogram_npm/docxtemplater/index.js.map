{"version":3,"sources":["docxtemplater.js","doc-utils.js","errors.js","utils.js","traits.js","module-wrapper.js","scope-manager.js","error-logger.js","collect-content-types.js","modules/common.js","filetypes.js","lexer.js","xml-templater.js","xml-matcher.js","parser.js","prefix-matcher.js","render.js","postrender.js","resolve.js","join-uncorrupt.js","file-type-config.js","modules/loop.js","modules/space-preserve.js","modules/rawxml.js","modules/expand-pair-trait.js","merge-sort.js","modules/render.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA;ADIA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,ACHA;AFOA,ADGA,AENA,AENA,ADGA;AFOA,ADGA,AENA,AENA,ADGA;AFOA,ADGA,AENA,AENA,ADGA;AFOA,ADGA,AENA,AGTA,ADGA,ADGA;AFOA,ADGA,AENA,AGTA,ADGA,ADGA;AFOA,ADGA,AENA,AGTA,ADGA,ADGA;AFOA,ADGA,AENA,AGTA,ACHA,AFMA,ADGA;AFOA,ADGA,AENA,AGTA,ACHA,AFMA,ADGA;AFOA,ADGA,AENA,AGTA,ACHA,AFMA,ADGA;AFOA,ADGA,AOrBA,ALeA,AGTA,ACHA,AFMA;AHUA,ADGA,AOrBA,ALeA,AGTA,ACHA,AFMA;AHUA,ADGA,AOrBA,ALeA,AGTA,ACHA,AFMA;AIXA,APqBA,ADGA,AOrBA,ALeA,AGTA,ACHA,AFMA;AIXA,APqBA,ADGA,AOrBA,ALeA,AGTA,ACHA,AFMA;AIXA,APqBA,ADGA,AOrBA,ALeA,AGTA,ACHA,AFMA;AIXA,APqBA,ADGA,AOrBA,ALeA,AGTA,AIZA,AHSA,AFMA;AIXA,APqBA,ADGA,AOrBA,ALeA,AGTA,AIZA,AHSA,AFMA;AIXA,APqBA,ADGA,AOrBA,ALeA,AGTA,AIZA,AHSA,AFMA;AIXA,APqBA,ADGA,AOrBA,ALeA,AQxBA,ALeA,AIZA,AHSA,AFMA;AIXA,APqBA,ADGA,AOrBA,ALeA,AQxBA,ALeA,AIZA,AHSA,AFMA;AIXA,APqBA,ADGA,AOrBA,ALeA,AQxBA,ALeA,AIZA,AHSA,AFMA;AIXA,APqBA,ADGA,AOrBA,ALeA,AQxBA,ACHA,ANkBA,AIZA,AHSA,AFMA;AIXA,APqBA,ADGA,AOrBA,ALeA,AQxBA,ACHA,ANkBA,AIZA,AHSA,AFMA;AIXA,APqBA,ADGA,AOrBA,ALeA,AQxBA,ACHA,ANkBA,AIZA,AHSA,AFMA;AIXA,APqBA,ADGA,AOrBA,ALeA,AQxBA,ACHA,ANkBA,AIZA,AHSA,AFMA,AQxBA;AJaA,APqBA,ADGA,AOrBA,ALeA,AQxBA,ACHA,ANkBA,AIZA,AHSA,AFMA,AQxBA;AJaA,APqBA,ADGA,AOrBA,ALeA,AQxBA,ACHA,ANkBA,AIZA,AHSA,AFMA,AQxBA;AJaA,APqBA,ADGA,AOrBA,ALeA,AQxBA,ACHA,ANkBA,AIZA,AHSA,AFMA,AS3BA,ADGA;AJaA,APqBA,ADGA,AOrBA,ALeA,AQxBA,ACHA,ANkBA,AIZA,AHSA,AFMA,AS3BA,ADGA;AJaA,APqBA,ADGA,AOrBA,ALeA,AQxBA,ACHA,ANkBA,AIZA,AHSA,AFMA,AS3BA,ADGA;AJaA,APqBA,ADGA,AOrBA,ALeA,AQxBA,ACHA,ANkBA,AIZA,AKfA,ARwBA,AFMA,AS3BA,ADGA;AJaA,APqBA,ADGA,AOrBA,ALeA,AQxBA,ACHA,ANkBA,AIZA,AKfA,ARwBA,AFMA,AS3BA,ADGA;AJaA,APqBA,ADGA,AOrBA,ALeA,AQxBA,ACHA,ANkBA,AIZA,AKfA,ARwBA,AFMA,AS3BA,ADGA;AJaA,APqBA,ADGA,AOrBA,ALeA,AQxBA,ACHA,ANkBA,AIZA,AKfA,ACHA,AT2BA,AFMA,AS3BA,ADGA;AJaA,APqBA,ADGA,AOrBA,ALeA,AQxBA,ACHA,ANkBA,AIZA,AKfA,ACHA,AT2BA,AFMA,AS3BA,ADGA;AJaA,APqBA,ADGA,AOrBA,ALeA,AQxBA,ACHA,ANkBA,AIZA,AKfA,ACHA,AT2BA,AFMA,AS3BA,ADGA;AJaA,APqBA,ADGA,AOrBA,ALeA,AQxBA,ACHA,ANkBA,AIZA,AKfA,ACHA,ACHA,AV8BA,AFMA,AS3BA,ADGA;AJaA,APqBA,ADGA,AOrBA,ALeA,AQxBA,ACHA,ANkBA,AIZA,AKfA,ACHA,ACHA,AV8BA,AFMA,AS3BA,ADGA;AJaA,APqBA,ADGA,AOrBA,ALeA,AS3BA,ANkBA,AIZA,AKfA,ACHA,ACHA,AV8BA,AFMA,AS3BA,ADGA;AJaA,APqBA,ADGA,AOrBA,ALeA,AS3BA,ANkBA,AIZA,AKfA,AGTA,AFMA,ACHA,AV8BA,AFMA,AS3BA,ADGA;AJaA,APqBA,ADGA,AOrBA,ALeA,AS3BA,ANkBA,AIZA,AKfA,AGTA,AFMA,ACHA,AV8BA,AFMA,AQxBA;AXkCA,ADGA,AOrBA,ALeA,AS3BA,ANkBA,AIZA,AKfA,AGTA,AFMA,ACHA,AV8BA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,ANkBA,AIZA,AKfA,AGTA,AFMA,ACHA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,ANkBA,AIZA,AKfA,AGTA,AFMA,ACHA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,ANkBA,AIZA,AKfA,AGTA,AFMA,ACHA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AiBnDA,ARwBA,ANkBA,AIZA,AKfA,AGTA,AFMA,ACHA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AiBnDA,ARwBA,AFMA,AKfA,AGTA,AFMA,ACHA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AiBnDA,ARwBA,AFMA,AKfA,AGTA,AFMA,ACHA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AFMA,AKfA,AGTA,AFMA,ACHA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AFMA,AKfA,AGTA,AFMA,ACHA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AFMA,AKfA,AGTA,AFMA,ACHA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AFMA,AYpCA,APqBA,AGTA,AFMA,ACHA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AFMA,AYpCA,APqBA,AGTA,AFMA,ACHA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AFMA,AYpCA,APqBA,AGTA,AFMA,ACHA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AFMA,AYpCA,ACHA,ARwBA,AGTA,AFMA,ACHA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AFMA,AYpCA,ACHA,ARwBA,AGTA,AFMA,ACHA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AFMA,AYpCA,ACHA,ARwBA,AGTA,AFMA,ACHA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AFMA,AYpCA,AENA,ADGA,ARwBA,AGTA,AFMA,ACHA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AFMA,AYpCA,AENA,ADGA,ARwBA,AGTA,AFMA,ACHA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AFMA,AYpCA,AENA,ADGA,ARwBA,AGTA,AFMA,ACHA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AFMA,Ae7CA,AHSA,AENA,ADGA,ARwBA,AGTA,AFMA,ACHA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AFMA,Ae7CA,AHSA,AENA,ADGA,ARwBA,AGTA,AFMA,ACHA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AFMA,Ae7CA,AHSA,AENA,ADGA,ARwBA,AGTA,AFMA,ACHA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,ADGA,ARwBA,AGTA,AFMA,ACHA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,ADGA,ARwBA,AGTA,AFMA,ACHA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,ADGA,ARwBA,AGTA,AFMA,ACHA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AFMA,ACHA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AFMA,ACHA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ADGA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ADGA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ADGA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ADGA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ADGA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ADGA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ADGA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ADGA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ADGA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ADGA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ADGA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ADGA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,AhBgDA,Ae7CA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ADGA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ADGA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ADGA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ADGA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ADGA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ADGA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ADGA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ADGA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ADGA,AENA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,Ac1CA,ADGA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,ACHA,AZoCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AkBtDA,ADGA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AiBnDA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AiBnDA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AiBnDA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AiBnDA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AiBnDA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AiBnDA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AiBnDA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AiBnDA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AiBnDA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AiBnDA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AiBnDA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AiBnDA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AiBnDA,ARwBA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,AGTA,AXiCA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AENA,AGTA,AJYA,ARwBA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AJYA,ARwBA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AKfA,AZoCA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,APqBA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,APqBA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,APqBA,ARwBA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,Af6CA,AFMA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA,AQxBA;AXkCA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AavCA,AHSA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AU9BA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AU9BA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AU9BA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AU9BA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AU9BA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AU9BA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AU9BA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AU9BA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AU9BA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AU9BA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AU9BA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AU9BA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AU9BA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AU9BA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AU9BA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AU9BA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AU9BA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AU9BA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AU9BA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AU9BA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AU9BA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AU9BA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AU9BA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AU9BA,AjBmDA;AHUA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AENA,AS3BA,AU9BA;ApB6DA,ADGA,AWjCA,AU9BA;ApB6DA,ADGA,AWjCA,AU9BA;ApB6DA,ADGA,AWjCA,AU9BA;ApB6DA,ADGA,AWjCA,AU9BA;ApB6DA,ADGA,AWjCA,AU9BA;ApB6DA,ADGA,AWjCA,AU9BA;ApB6DA,ADGA,AWjCA,AU9BA;ApB6DA,ADGA,AWjCA,AU9BA;ApB6DA,ADGA,AWjCA,AU9BA;ApB6DA,ADGA,AWjCA,AU9BA;ApB6DA,ADGA,AWjCA,AU9BA;ApB6DA,ADGA,AWjCA,AU9BA;ApB6DA,ADGA,AWjCA,AU9BA;ApB6DA,ADGA,AWjCA,AU9BA;ApB6DA,ADGA,AWjCA,AU9BA;ApB6DA,ADGA,AWjCA,AU9BA;ApB6DA,ADGA,AWjCA,AU9BA;ApB6DA,ADGA,AWjCA,AU9BA;ApB6DA,ADGA,AWjCA,AU9BA;ApB6DA,ADGA,AWjCA,AU9BA;ApB6DA,ADGA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AWjCA,AU9BA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;ArBgEA,AqB/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nvar _excluded = [\"modules\"];\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar DocUtils = require(\"./doc-utils.js\");\nDocUtils.traits = require(\"./traits.js\");\nDocUtils.moduleWrapper = require(\"./module-wrapper.js\");\nvar createScope = require(\"./scope-manager.js\");\nvar _require = require(\"./errors.js\"),\n  throwMultiError = _require.throwMultiError,\n  throwResolveBeforeCompile = _require.throwResolveBeforeCompile,\n  throwRenderInvalidTemplate = _require.throwRenderInvalidTemplate,\n  throwRenderTwice = _require.throwRenderTwice;\nvar logErrors = require(\"./error-logger.js\");\nvar collectContentTypes = require(\"./collect-content-types.js\");\nvar ctXML = \"[Content_Types].xml\";\nvar relsFile = \"_rels/.rels\";\nvar commonModule = require(\"./modules/common.js\");\nvar Lexer = require(\"./lexer.js\");\nvar defaults = DocUtils.defaults,\n  str2xml = DocUtils.str2xml,\n  xml2str = DocUtils.xml2str,\n  moduleWrapper = DocUtils.moduleWrapper,\n  concatArrays = DocUtils.concatArrays,\n  uniq = DocUtils.uniq,\n  stableSort = DocUtils.stableSort;\nvar _require2 = require(\"./errors.js\"),\n  XTInternalError = _require2.XTInternalError,\n  throwFileTypeNotIdentified = _require2.throwFileTypeNotIdentified,\n  throwFileTypeNotHandled = _require2.throwFileTypeNotHandled,\n  throwApiVersionError = _require2.throwApiVersionError;\nvar currentModuleApiVersion = [3, 36, 0];\nfunction dropUnsupportedFileTypesModules(dx) {\n  dx.modules = dx.modules.filter(function (module) {\n    if (module.supportedFileTypes) {\n      if (!Array.isArray(module.supportedFileTypes)) {\n        throw new Error(\"The supportedFileTypes field of the module must be an array\");\n      }\n      var isSupportedModule = module.supportedFileTypes.indexOf(dx.fileType) !== -1;\n      if (!isSupportedModule) {\n        module.on(\"detached\");\n      }\n      return isSupportedModule;\n    }\n    return true;\n  });\n}\nvar Docxtemplater = /*#__PURE__*/function () {\n  function Docxtemplater(zip) {\n    var _this = this;\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n      _ref$modules = _ref.modules,\n      modules = _ref$modules === void 0 ? [] : _ref$modules,\n      options = _objectWithoutProperties(_ref, _excluded);\n    _classCallCheck(this, Docxtemplater);\n    if (!Array.isArray(modules)) {\n      throw new Error(\"The modules argument of docxtemplater's constructor must be an array\");\n    }\n    this.targets = [];\n    this.rendered = false;\n    this.scopeManagers = {};\n    this.compiled = {};\n    this.modules = [commonModule()];\n    this.setOptions(options);\n    modules.forEach(function (module) {\n      _this.attachModule(module);\n    });\n    if (arguments.length > 0) {\n      if (!zip || !zip.files || typeof zip.file !== \"function\") {\n        throw new Error(\"The first argument of docxtemplater's constructor must be a valid zip file (jszip v2 or pizzip v3)\");\n      }\n      this.loadZip(zip);\n      // remove the unsupported modules\n      dropUnsupportedFileTypesModules(this);\n      this.compile();\n      this.v4Constructor = true;\n    }\n  }\n  _createClass(Docxtemplater, [{\n    key: \"verifyApiVersion\",\n    value: function verifyApiVersion(neededVersion) {\n      neededVersion = neededVersion.split(\".\").map(function (i) {\n        return parseInt(i, 10);\n      });\n      if (neededVersion.length !== 3) {\n        throwApiVersionError(\"neededVersion is not a valid version\", {\n          neededVersion: neededVersion,\n          explanation: \"the neededVersion must be an array of length 3\"\n        });\n      }\n      if (neededVersion[0] !== currentModuleApiVersion[0]) {\n        throwApiVersionError(\"The major api version do not match, you probably have to update docxtemplater with npm install --save docxtemplater\", {\n          neededVersion: neededVersion,\n          currentModuleApiVersion: currentModuleApiVersion,\n          explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\n        });\n      }\n      if (neededVersion[1] > currentModuleApiVersion[1]) {\n        throwApiVersionError(\"The minor api version is not uptodate, you probably have to update docxtemplater with npm install --save docxtemplater\", {\n          neededVersion: neededVersion,\n          currentModuleApiVersion: currentModuleApiVersion,\n          explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\n        });\n      }\n      if (neededVersion[1] === currentModuleApiVersion[1] && neededVersion[2] > currentModuleApiVersion[2]) {\n        throwApiVersionError(\"The patch api version is not uptodate, you probably have to update docxtemplater with npm install --save docxtemplater\", {\n          neededVersion: neededVersion,\n          currentModuleApiVersion: currentModuleApiVersion,\n          explanation: \"moduleAPIVersionMismatch : needed=\".concat(neededVersion.join(\".\"), \", current=\").concat(currentModuleApiVersion.join(\".\"))\n        });\n      }\n      return true;\n    }\n  }, {\n    key: \"setModules\",\n    value: function setModules(obj) {\n      this.modules.forEach(function (module) {\n        module.set(obj);\n      });\n    }\n  }, {\n    key: \"sendEvent\",\n    value: function sendEvent(eventName) {\n      this.modules.forEach(function (module) {\n        module.on(eventName);\n      });\n    }\n  }, {\n    key: \"attachModule\",\n    value: function attachModule(module) {\n      if (this.v4Constructor) {\n        throw new XTInternalError(\"attachModule() should not be called manually when using the v4 constructor\");\n      }\n      var moduleType = _typeof(module);\n      if (moduleType === \"function\") {\n        throw new XTInternalError(\"Cannot attach a class/function as a module. Most probably you forgot to instantiate the module by using `new` on the module.\");\n      }\n      if (!module || moduleType !== \"object\") {\n        throw new XTInternalError(\"Cannot attachModule with a falsy value\");\n      }\n      if (module.requiredAPIVersion) {\n        this.verifyApiVersion(module.requiredAPIVersion);\n      }\n      if (module.attached === true) {\n        if (typeof module.clone === \"function\") {\n          module = module.clone();\n        } else {\n          throw new Error(\"Cannot attach a module that was already attached : \\\"\".concat(module.name, \"\\\". The most likely cause is that you are instantiating the module at the root level, and using it for multiple instances of Docxtemplater\"));\n        }\n      }\n      module.attached = true;\n      var wrappedModule = moduleWrapper(module);\n      this.modules.push(wrappedModule);\n      wrappedModule.on(\"attached\");\n      if (this.fileType) {\n        dropUnsupportedFileTypesModules(this);\n      }\n      return this;\n    }\n  }, {\n    key: \"setOptions\",\n    value: function setOptions(options) {\n      var _this2 = this;\n      if (this.v4Constructor) {\n        throw new Error(\"setOptions() should not be called manually when using the v4 constructor\");\n      }\n      if (!options) {\n        throw new Error(\"setOptions should be called with an object as first parameter\");\n      }\n      this.options = {};\n      Object.keys(defaults).forEach(function (key) {\n        var defaultValue = defaults[key];\n        _this2.options[key] = options[key] != null ? options[key] : defaultValue;\n        _this2[key] = _this2.options[key];\n      });\n      this.delimiters.start = DocUtils.utf8ToWord(this.delimiters.start);\n      this.delimiters.end = DocUtils.utf8ToWord(this.delimiters.end);\n      if (this.zip) {\n        this.updateFileTypeConfig();\n      }\n      return this;\n    }\n  }, {\n    key: \"loadZip\",\n    value: function loadZip(zip) {\n      if (this.v4Constructor) {\n        throw new Error(\"loadZip() should not be called manually when using the v4 constructor\");\n      }\n      if (zip.loadAsync) {\n        throw new XTInternalError(\"Docxtemplater doesn't handle JSZip version >=3, please use pizzip\");\n      }\n      this.zip = zip;\n      this.updateFileTypeConfig();\n      this.modules = concatArrays([this.fileTypeConfig.baseModules.map(function (moduleFunction) {\n        return moduleFunction();\n      }), this.modules]);\n      dropUnsupportedFileTypesModules(this);\n      return this;\n    }\n  }, {\n    key: \"precompileFile\",\n    value: function precompileFile(fileName) {\n      var currentFile = this.createTemplateClass(fileName);\n      currentFile.preparse();\n      this.compiled[fileName] = currentFile;\n    }\n  }, {\n    key: \"compileFile\",\n    value: function compileFile(fileName) {\n      this.compiled[fileName].parse();\n    }\n  }, {\n    key: \"getScopeManager\",\n    value: function getScopeManager(to, currentFile, tags) {\n      if (!this.scopeManagers[to]) {\n        this.scopeManagers[to] = createScope({\n          tags: tags,\n          parser: this.parser,\n          cachedParsers: currentFile.cachedParsers\n        });\n      }\n      return this.scopeManagers[to];\n    }\n  }, {\n    key: \"resolveData\",\n    value: function resolveData(data) {\n      var _this3 = this;\n      var errors = [];\n      if (!Object.keys(this.compiled).length) {\n        throwResolveBeforeCompile();\n      }\n      return Promise.resolve(data).then(function (data) {\n        _this3.setData(data);\n        _this3.setModules({\n          data: _this3.data,\n          Lexer: Lexer\n        });\n        _this3.mapper = _this3.modules.reduce(function (value, module) {\n          return module.getRenderedMap(value);\n        }, {});\n        return Promise.all(Object.keys(_this3.mapper).map(function (to) {\n          var _this3$mapper$to = _this3.mapper[to],\n            from = _this3$mapper$to.from,\n            data = _this3$mapper$to.data;\n          return Promise.resolve(data).then(function (data) {\n            var currentFile = _this3.compiled[from];\n            currentFile.filePath = to;\n            currentFile.scopeManager = _this3.getScopeManager(to, currentFile, data);\n            return currentFile.resolveTags(data).then(function (result) {\n              currentFile.scopeManager.finishedResolving = true;\n              return result;\n            }, function (errs) {\n              Array.prototype.push.apply(errors, errs);\n            });\n          });\n        })).then(function (resolved) {\n          if (errors.length !== 0) {\n            if (_this3.options.errorLogging) {\n              logErrors(errors, _this3.options.errorLogging);\n            }\n            throwMultiError(errors);\n          }\n          return concatArrays(resolved);\n        });\n      });\n    }\n  }, {\n    key: \"reorderModules\",\n    value: function reorderModules() {\n      this.modules = stableSort(this.modules, function (m1, m2) {\n        return (m2.priority || 0) - (m1.priority || 0);\n      });\n    }\n  }, {\n    key: \"compile\",\n    value: function compile() {\n      var _this4 = this;\n      this.reorderModules();\n      if (Object.keys(this.compiled).length) {\n        return this;\n      }\n      this.options = this.modules.reduce(function (options, module) {\n        return module.optionsTransformer(options, _this4);\n      }, this.options);\n      this.options.xmlFileNames = uniq(this.options.xmlFileNames);\n      this.xmlDocuments = this.options.xmlFileNames.reduce(function (xmlDocuments, fileName) {\n        var content = _this4.zip.files[fileName].asText();\n        xmlDocuments[fileName] = str2xml(content);\n        return xmlDocuments;\n      }, {});\n      this.setModules({\n        zip: this.zip,\n        xmlDocuments: this.xmlDocuments\n      });\n      this.getTemplatedFiles();\n      // Loop inside all templatedFiles (ie xml files with content).\n      // Sometimes they don't exist (footer.xml for example)\n      this.templatedFiles.forEach(function (fileName) {\n        if (_this4.zip.files[fileName] != null) {\n          _this4.precompileFile(fileName);\n        }\n      });\n      this.templatedFiles.forEach(function (fileName) {\n        if (_this4.zip.files[fileName] != null) {\n          _this4.compileFile(fileName);\n        }\n      });\n      this.setModules({\n        compiled: this.compiled\n      });\n      verifyErrors(this);\n      return this;\n    }\n  }, {\n    key: \"getRelsTypes\",\n    value: function getRelsTypes() {\n      var rootRels = this.zip.files[relsFile];\n      var rootRelsXml = rootRels ? str2xml(rootRels.asText()) : null;\n      var rootRelationships = rootRelsXml ? rootRelsXml.getElementsByTagName(\"Relationship\") : [];\n      var relsTypes = {};\n      for (var i = 0, len = rootRelationships.length; i < len; i++) {\n        var r = rootRelationships[i];\n        relsTypes[r.getAttribute(\"Target\")] = r.getAttribute(\"Type\");\n      }\n      return relsTypes;\n    }\n  }, {\n    key: \"getContentTypes\",\n    value: function getContentTypes() {\n      var contentTypes = this.zip.files[ctXML];\n      var contentTypeXml = contentTypes ? str2xml(contentTypes.asText()) : null;\n      var overrides = contentTypeXml ? contentTypeXml.getElementsByTagName(\"Override\") : null;\n      var defaults = contentTypeXml ? contentTypeXml.getElementsByTagName(\"Default\") : null;\n      return {\n        overrides: overrides,\n        defaults: defaults,\n        contentTypes: contentTypes,\n        contentTypeXml: contentTypeXml\n      };\n    }\n  }, {\n    key: \"updateFileTypeConfig\",\n    value: function updateFileTypeConfig() {\n      var _this5 = this;\n      var fileType;\n      if (this.zip.files.mimetype) {\n        fileType = \"odt\";\n      }\n      this.relsTypes = this.getRelsTypes();\n      var _this$getContentTypes = this.getContentTypes(),\n        overrides = _this$getContentTypes.overrides,\n        defaults = _this$getContentTypes.defaults,\n        contentTypes = _this$getContentTypes.contentTypes,\n        contentTypeXml = _this$getContentTypes.contentTypeXml;\n      if (contentTypeXml) {\n        this.filesContentTypes = collectContentTypes(overrides, defaults, this.zip);\n        this.invertedContentTypes = DocUtils.invertMap(this.filesContentTypes);\n        this.setModules({\n          contentTypes: this.contentTypes,\n          invertedContentTypes: this.invertedContentTypes\n        });\n      }\n      this.modules.forEach(function (module) {\n        fileType = module.getFileType({\n          zip: _this5.zip,\n          contentTypes: contentTypes,\n          contentTypeXml: contentTypeXml,\n          overrides: overrides,\n          defaults: defaults,\n          doc: _this5\n        }) || fileType;\n      });\n      if (fileType === \"odt\") {\n        throwFileTypeNotHandled(fileType);\n      }\n      if (!fileType) {\n        throwFileTypeNotIdentified();\n      }\n      this.fileType = fileType;\n      dropUnsupportedFileTypesModules(this);\n      this.fileTypeConfig = this.options.fileTypeConfig || this.fileTypeConfig || Docxtemplater.FileTypeConfig[this.fileType]();\n      return this;\n    }\n  }, {\n    key: \"renderAsync\",\n    value: function renderAsync(data) {\n      var _this6 = this;\n      return this.resolveData(data).then(function () {\n        return _this6.render();\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render(data) {\n      var _this7 = this;\n      if (this.rendered) {\n        throwRenderTwice();\n      }\n      this.rendered = true;\n      this.compile();\n      if (this.errors.length > 0) {\n        throwRenderInvalidTemplate();\n      }\n      if (data) {\n        this.setData(data);\n      }\n      this.setModules({\n        data: this.data,\n        Lexer: Lexer\n      });\n      this.mapper = this.mapper || this.modules.reduce(function (value, module) {\n        return module.getRenderedMap(value);\n      }, {});\n      Object.keys(this.mapper).forEach(function (to) {\n        var _this7$mapper$to = _this7.mapper[to],\n          from = _this7$mapper$to.from,\n          data = _this7$mapper$to.data;\n        var currentFile = _this7.compiled[from];\n        currentFile.scopeManager = _this7.getScopeManager(to, currentFile, data);\n        currentFile.render(to);\n        _this7.zip.file(to, currentFile.content, {\n          createFolders: true\n        });\n      });\n      verifyErrors(this);\n      this.sendEvent(\"syncing-zip\");\n      this.syncZip();\n      return this;\n    }\n  }, {\n    key: \"syncZip\",\n    value: function syncZip() {\n      var _this8 = this;\n      Object.keys(this.xmlDocuments).forEach(function (fileName) {\n        _this8.zip.remove(fileName);\n        var content = xml2str(_this8.xmlDocuments[fileName]);\n        return _this8.zip.file(fileName, content, {\n          createFolders: true\n        });\n      });\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(data) {\n      this.data = data;\n      return this;\n    }\n  }, {\n    key: \"getZip\",\n    value: function getZip() {\n      return this.zip;\n    }\n  }, {\n    key: \"createTemplateClass\",\n    value: function createTemplateClass(path) {\n      var content = this.zip.files[path].asText();\n      return this.createTemplateClassFromContent(content, path);\n    }\n  }, {\n    key: \"createTemplateClassFromContent\",\n    value: function createTemplateClassFromContent(content, filePath) {\n      var _this9 = this;\n      var xmltOptions = {\n        filePath: filePath,\n        contentType: this.filesContentTypes[filePath],\n        relsType: this.relsTypes[filePath]\n      };\n      Object.keys(defaults).concat([\"filesContentTypes\", \"fileTypeConfig\", \"fileType\", \"modules\"]).forEach(function (key) {\n        xmltOptions[key] = _this9[key];\n      });\n      return new Docxtemplater.XmlTemplater(content, xmltOptions);\n    }\n  }, {\n    key: \"getFullText\",\n    value: function getFullText(path) {\n      return this.createTemplateClass(path || this.fileTypeConfig.textPath(this)).getFullText();\n    }\n  }, {\n    key: \"getTemplatedFiles\",\n    value: function getTemplatedFiles() {\n      var _this10 = this;\n      this.templatedFiles = this.fileTypeConfig.getTemplatedFiles(this.zip);\n      this.targets.forEach(function (target) {\n        _this10.templatedFiles.push(target);\n      });\n      this.templatedFiles = uniq(this.templatedFiles);\n      return this.templatedFiles;\n    }\n  }]);\n  return Docxtemplater;\n}();\nfunction verifyErrors(doc) {\n  var compiled = doc.compiled;\n  doc.errors = concatArrays(Object.keys(compiled).map(function (name) {\n    return compiled[name].allErrors;\n  }));\n  if (doc.errors.length !== 0) {\n    if (doc.options.errorLogging) {\n      logErrors(doc.errors, doc.options.errorLogging);\n    }\n    throwMultiError(doc.errors);\n  }\n}\nDocxtemplater.DocUtils = DocUtils;\nDocxtemplater.Errors = require(\"./errors.js\");\nDocxtemplater.XmlTemplater = require(\"./xml-templater.js\");\nDocxtemplater.FileTypeConfig = require(\"./file-type-config.js\");\nDocxtemplater.XmlMatcher = require(\"./xml-matcher.js\");\nmodule.exports = Docxtemplater;","\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar _require = require(\"@xmldom/xmldom\"),\n  DOMParser = _require.DOMParser,\n  XMLSerializer = _require.XMLSerializer;\nvar _require2 = require(\"./errors.js\"),\n  throwXmlTagNotFound = _require2.throwXmlTagNotFound;\nvar _require3 = require(\"./utils.js\"),\n  last = _require3.last,\n  first = _require3.first;\nfunction isWhiteSpace(value) {\n  return /^[ \\n\\r\\t]+$/.test(value);\n}\nfunction parser(tag) {\n  return {\n    get: function get(scope) {\n      if (tag === \".\") {\n        return scope;\n      }\n      if (scope) {\n        return scope[tag];\n      }\n      return scope;\n    }\n  };\n}\nvar attrToRegex = {};\nfunction setSingleAttribute(partValue, attr, attrValue) {\n  var regex;\n  // Stryker disable next-line all : because this is an optimisation\n  if (attrToRegex[attr]) {\n    regex = attrToRegex[attr];\n  } else {\n    regex = new RegExp(\"(<.* \".concat(attr, \"=\\\")([^\\\"]*)(\\\".*)$\"));\n    attrToRegex[attr] = regex;\n  }\n  if (regex.test(partValue)) {\n    return partValue.replace(regex, \"$1\".concat(attrValue, \"$3\"));\n  }\n  var end = partValue.lastIndexOf(\"/>\");\n  if (end === -1) {\n    end = partValue.lastIndexOf(\">\");\n  }\n  return partValue.substr(0, end) + \" \".concat(attr, \"=\\\"\").concat(attrValue, \"\\\"\") + partValue.substr(end);\n}\nfunction getSingleAttribute(value, attributeName) {\n  var index = value.indexOf(\" \".concat(attributeName, \"=\\\"\"));\n  if (index === -1) {\n    return null;\n  }\n  var startIndex = value.substr(index).search(/[\"']/) + index;\n  var endIndex = value.substr(startIndex + 1).search(/[\"']/) + startIndex;\n  return value.substr(startIndex + 1, endIndex - startIndex);\n}\nfunction endsWith(str, suffix) {\n  return str.indexOf(suffix, str.length - suffix.length) !== -1;\n}\nfunction startsWith(str, prefix) {\n  return str.substring(0, prefix.length) === prefix;\n}\nfunction uniq(arr) {\n  var hash = {},\n    result = [];\n  for (var i = 0, l = arr.length; i < l; ++i) {\n    if (!hash[arr[i]]) {\n      hash[arr[i]] = true;\n      result.push(arr[i]);\n    }\n  }\n  return result;\n}\nfunction chunkBy(parsed, f) {\n  return parsed.reduce(function (chunks, p) {\n    var currentChunk = last(chunks);\n    var res = f(p);\n    if (res === \"start\") {\n      chunks.push([p]);\n    } else if (res === \"end\") {\n      currentChunk.push(p);\n      chunks.push([]);\n    } else {\n      currentChunk.push(p);\n    }\n    return chunks;\n  }, [[]]).filter(function (p) {\n    return p.length > 0;\n  });\n}\nvar defaults = {\n  errorLogging: \"json\",\n  paragraphLoop: false,\n  nullGetter: function nullGetter(part) {\n    return part.module ? \"\" : \"undefined\";\n  },\n  xmlFileNames: [\"[Content_Types].xml\"],\n  parser: parser,\n  linebreaks: false,\n  fileTypeConfig: null,\n  delimiters: {\n    start: \"{\",\n    end: \"}\"\n  }\n};\nfunction mergeObjects() {\n  var resObj = {};\n  var obj;\n  for (var i = 0; i < arguments.length; i += 1) {\n    obj = arguments[i];\n    resObj = _objectSpread(_objectSpread({}, resObj), obj);\n  }\n  return resObj;\n}\nfunction xml2str(xmlNode) {\n  var a = new XMLSerializer();\n  return a.serializeToString(xmlNode).replace(/xmlns(:[a-z0-9]+)?=\"\" ?/g, \"\");\n}\nfunction str2xml(str) {\n  if (str.charCodeAt(0) === 65279) {\n    // BOM sequence\n    str = str.substr(1);\n  }\n  return new DOMParser().parseFromString(str, \"text/xml\");\n}\nvar charMap = [[\"&\", \"&amp;\"], [\"<\", \"&lt;\"], [\">\", \"&gt;\"], ['\"', \"&quot;\"], [\"'\", \"&apos;\"]];\nvar charMapRegexes = charMap.map(function (_ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n    endChar = _ref2[0],\n    startChar = _ref2[1];\n  return {\n    rstart: new RegExp(startChar, \"g\"),\n    rend: new RegExp(endChar, \"g\"),\n    start: startChar,\n    end: endChar\n  };\n});\nfunction wordToUtf8(string) {\n  var r;\n  for (var i = charMapRegexes.length - 1; i >= 0; i--) {\n    r = charMapRegexes[i];\n    string = string.replace(r.rstart, r.end);\n  }\n  return string;\n}\nfunction utf8ToWord(string) {\n  // To make sure that the object given is a string (this is a noop for strings).\n  string = string.toString();\n  var r;\n  for (var i = 0, l = charMapRegexes.length; i < l; i++) {\n    r = charMapRegexes[i];\n    string = string.replace(r.rend, r.start);\n  }\n  return string;\n}\n\n// This function is written with for loops for performance\nfunction concatArrays(arrays) {\n  var result = [];\n  for (var i = 0; i < arrays.length; i++) {\n    var array = arrays[i];\n    for (var j = 0, len = array.length; j < len; j++) {\n      result.push(array[j]);\n    }\n  }\n  return result;\n}\nvar spaceRegexp = new RegExp(String.fromCharCode(160), \"g\");\nfunction convertSpaces(s) {\n  return s.replace(spaceRegexp, \" \");\n}\nfunction pregMatchAll(regex, content) {\n  /* regex is a string, content is the content. It returns an array of all matches with their offset, for example:\n  \t regex=la\n  \t content=lolalolilala\n  returns: [{array: {0: 'la'},offset: 2},{array: {0: 'la'},offset: 8},{array: {0: 'la'} ,offset: 10}]\n  */\n  var matchArray = [];\n  var match;\n  while ((match = regex.exec(content)) != null) {\n    matchArray.push({\n      array: match,\n      offset: match.index\n    });\n  }\n  return matchArray;\n}\nfunction isEnding(value, element) {\n  return value === \"</\" + element + \">\";\n}\nfunction isStarting(value, element) {\n  return value.indexOf(\"<\" + element) === 0 && [\">\", \" \", \"/\"].indexOf(value[element.length + 1]) !== -1;\n}\nfunction getRight(parsed, element, index) {\n  var val = getRightOrNull(parsed, element, index);\n  if (val !== null) {\n    return val;\n  }\n  throwXmlTagNotFound({\n    position: \"right\",\n    element: element,\n    parsed: parsed,\n    index: index\n  });\n}\nfunction getRightOrNull(parsed, elements, index) {\n  if (typeof elements === \"string\") {\n    elements = [elements];\n  }\n  var level = 1;\n  for (var i = index, l = parsed.length; i < l; i++) {\n    var part = parsed[i];\n    for (var j = 0, len = elements.length; j < len; j++) {\n      var element = elements[j];\n      if (isEnding(part.value, element)) {\n        level--;\n      }\n      if (isStarting(part.value, element)) {\n        level++;\n      }\n      if (level === 0) {\n        return i;\n      }\n    }\n  }\n  return null;\n}\nfunction getLeft(parsed, element, index) {\n  var val = getLeftOrNull(parsed, element, index);\n  if (val !== null) {\n    return val;\n  }\n  throwXmlTagNotFound({\n    position: \"left\",\n    element: element,\n    parsed: parsed,\n    index: index\n  });\n}\nfunction getLeftOrNull(parsed, elements, index) {\n  if (typeof elements === \"string\") {\n    elements = [elements];\n  }\n  var level = 1;\n  for (var i = index; i >= 0; i--) {\n    var part = parsed[i];\n    for (var j = 0, len = elements.length; j < len; j++) {\n      var element = elements[j];\n      if (isStarting(part.value, element)) {\n        level--;\n      }\n      if (isEnding(part.value, element)) {\n        level++;\n      }\n      if (level === 0) {\n        return i;\n      }\n    }\n  }\n  return null;\n}\n\n// Stryker disable all : because those are functions that depend on the parsed\n// structure based and we don't want minimal code here, but rather code that\n// makes things clear.\nfunction isTagStart(tagType, _ref3) {\n  var type = _ref3.type,\n    tag = _ref3.tag,\n    position = _ref3.position;\n  return type === \"tag\" && tag === tagType && (position === \"start\" || position === \"selfclosing\");\n}\nfunction isTagStartStrict(tagType, _ref4) {\n  var type = _ref4.type,\n    tag = _ref4.tag,\n    position = _ref4.position;\n  return type === \"tag\" && tag === tagType && position === \"start\";\n}\nfunction isTagEnd(tagType, _ref5) {\n  var type = _ref5.type,\n    tag = _ref5.tag,\n    position = _ref5.position;\n  return type === \"tag\" && tag === tagType && position === \"end\";\n}\nfunction isParagraphStart(part) {\n  return isTagStartStrict(\"w:p\", part) || isTagStartStrict(\"a:p\", part);\n}\nfunction isParagraphEnd(part) {\n  return isTagEnd(\"w:p\", part) || isTagEnd(\"a:p\", part);\n}\nfunction isTextStart(_ref6) {\n  var type = _ref6.type,\n    position = _ref6.position,\n    text = _ref6.text;\n  return type === \"tag\" && position === \"start\" && text;\n}\nfunction isTextEnd(_ref7) {\n  var type = _ref7.type,\n    position = _ref7.position,\n    text = _ref7.text;\n  return type === \"tag\" && position === \"end\" && text;\n}\nfunction isContent(_ref8) {\n  var type = _ref8.type,\n    position = _ref8.position;\n  return type === \"placeholder\" || type === \"content\" && position === \"insidetag\";\n}\nfunction isModule(_ref9, modules) {\n  var module = _ref9.module,\n    type = _ref9.type;\n  if (!(modules instanceof Array)) {\n    modules = [modules];\n  }\n  return type === \"placeholder\" && modules.indexOf(module) !== -1;\n}\n// Stryker restore all\n\nvar corruptCharacters = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F]/;\n// 00    NUL '\\0' (null character)\n// 01    SOH (start of heading)\n// 02    STX (start of text)\n// 03    ETX (end of text)\n// 04    EOT (end of transmission)\n// 05    ENQ (enquiry)\n// 06    ACK (acknowledge)\n// 07    BEL '\\a' (bell)\n// 08    BS  '\\b' (backspace)\n// 0B    VT  '\\v' (vertical tab)\n// 0C    FF  '\\f' (form feed)\n// 0E    SO  (shift out)\n// 0F    SI  (shift in)\n// 10    DLE (data link escape)\n// 11    DC1 (device control 1)\n// 12    DC2 (device control 2)\n// 13    DC3 (device control 3)\n// 14    DC4 (device control 4)\n// 15    NAK (negative ack.)\n// 16    SYN (synchronous idle)\n// 17    ETB (end of trans. blk)\n// 18    CAN (cancel)\n// 19    EM  (end of medium)\n// 1A    SUB (substitute)\n// 1B    ESC (escape)\n// 1C    FS  (file separator)\n// 1D    GS  (group separator)\n// 1E    RS  (record separator)\n// 1F    US  (unit separator)\nfunction hasCorruptCharacters(string) {\n  return corruptCharacters.test(string);\n}\nfunction invertMap(map) {\n  return Object.keys(map).reduce(function (invertedMap, key) {\n    var value = map[key];\n    invertedMap[value] = invertedMap[value] || [];\n    invertedMap[value].push(key);\n    return invertedMap;\n  }, {});\n}\nfunction stableSort(arr, compare) {\n  return arr.map(function (item, index) {\n    return {\n      item: item,\n      index: index\n    };\n  }).sort(function (a, b) {\n    return compare(a.item, b.item) || a.index - b.index;\n  }).map(function (_ref10) {\n    var item = _ref10.item;\n    return item;\n  });\n}\nmodule.exports = {\n  endsWith: endsWith,\n  startsWith: startsWith,\n  isContent: isContent,\n  isParagraphStart: isParagraphStart,\n  isParagraphEnd: isParagraphEnd,\n  isTagStart: isTagStart,\n  isTagEnd: isTagEnd,\n  isTextStart: isTextStart,\n  isTextEnd: isTextEnd,\n  isStarting: isStarting,\n  isEnding: isEnding,\n  isModule: isModule,\n  uniq: uniq,\n  chunkBy: chunkBy,\n  last: last,\n  first: first,\n  mergeObjects: mergeObjects,\n  xml2str: xml2str,\n  str2xml: str2xml,\n  getRightOrNull: getRightOrNull,\n  getRight: getRight,\n  getLeftOrNull: getLeftOrNull,\n  getLeft: getLeft,\n  pregMatchAll: pregMatchAll,\n  convertSpaces: convertSpaces,\n  charMapRegexes: charMapRegexes,\n  hasCorruptCharacters: hasCorruptCharacters,\n  defaults: defaults,\n  wordToUtf8: wordToUtf8,\n  utf8ToWord: utf8ToWord,\n  concatArrays: concatArrays,\n  invertMap: invertMap,\n  charMap: charMap,\n  getSingleAttribute: getSingleAttribute,\n  setSingleAttribute: setSingleAttribute,\n  isWhiteSpace: isWhiteSpace,\n  stableSort: stableSort\n};","\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar _require = require(\"./utils.js\"),\n  last = _require.last,\n  first = _require.first;\nfunction XTError(message) {\n  this.name = \"GenericError\";\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTError.prototype = Error.prototype;\nfunction XTTemplateError(message) {\n  this.name = \"TemplateError\";\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTTemplateError.prototype = new XTError();\nfunction XTRenderingError(message) {\n  this.name = \"RenderingError\";\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTRenderingError.prototype = new XTError();\nfunction XTScopeParserError(message) {\n  this.name = \"ScopeParserError\";\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTScopeParserError.prototype = new XTError();\nfunction XTInternalError(message) {\n  this.name = \"InternalError\";\n  this.properties = {\n    explanation: \"InternalError\"\n  };\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTInternalError.prototype = new XTError();\nfunction XTAPIVersionError(message) {\n  this.name = \"APIVersionError\";\n  this.properties = {\n    explanation: \"APIVersionError\"\n  };\n  this.message = message;\n  this.stack = new Error(message).stack;\n}\nXTAPIVersionError.prototype = new XTError();\nfunction throwApiVersionError(msg, properties) {\n  var err = new XTAPIVersionError(msg);\n  err.properties = _objectSpread({\n    id: \"api_version_error\"\n  }, properties);\n  throw err;\n}\nfunction throwMultiError(errors) {\n  var err = new XTTemplateError(\"Multi error\");\n  err.properties = {\n    errors: errors,\n    id: \"multi_error\",\n    explanation: \"The template has multiple errors\"\n  };\n  throw err;\n}\nfunction getUnopenedTagException(options) {\n  var err = new XTTemplateError(\"Unopened tag\");\n  err.properties = {\n    xtag: last(options.xtag.split(\" \")),\n    id: \"unopened_tag\",\n    context: options.xtag,\n    offset: options.offset,\n    lIndex: options.lIndex,\n    explanation: \"The tag beginning with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" is unopened\")\n  };\n  return err;\n}\nfunction getDuplicateOpenTagException(options) {\n  var err = new XTTemplateError(\"Duplicate open tag, expected one open tag\");\n  err.properties = {\n    xtag: first(options.xtag.split(\" \")),\n    id: \"duplicate_open_tag\",\n    context: options.xtag,\n    offset: options.offset,\n    lIndex: options.lIndex,\n    explanation: \"The tag beginning with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" has duplicate open tags\")\n  };\n  return err;\n}\nfunction getDuplicateCloseTagException(options) {\n  var err = new XTTemplateError(\"Duplicate close tag, expected one close tag\");\n  err.properties = {\n    xtag: first(options.xtag.split(\" \")),\n    id: \"duplicate_close_tag\",\n    context: options.xtag,\n    offset: options.offset,\n    lIndex: options.lIndex,\n    explanation: \"The tag ending with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" has duplicate close tags\")\n  };\n  return err;\n}\nfunction getUnclosedTagException(options) {\n  var err = new XTTemplateError(\"Unclosed tag\");\n  err.properties = {\n    xtag: first(options.xtag.split(\" \")).substr(1),\n    id: \"unclosed_tag\",\n    context: options.xtag,\n    offset: options.offset,\n    lIndex: options.lIndex,\n    explanation: \"The tag beginning with \\\"\".concat(options.xtag.substr(0, 10), \"\\\" is unclosed\")\n  };\n  return err;\n}\nfunction throwXmlTagNotFound(options) {\n  var err = new XTTemplateError(\"No tag \\\"\".concat(options.element, \"\\\" was found at the \").concat(options.position));\n  var part = options.parsed[options.index];\n  err.properties = {\n    id: \"no_xml_tag_found_at_\".concat(options.position),\n    explanation: \"No tag \\\"\".concat(options.element, \"\\\" was found at the \").concat(options.position),\n    offset: part.offset,\n    part: part,\n    parsed: options.parsed,\n    index: options.index,\n    element: options.element\n  };\n  throw err;\n}\nfunction getCorruptCharactersException(_ref) {\n  var tag = _ref.tag,\n    value = _ref.value,\n    offset = _ref.offset;\n  var err = new XTRenderingError(\"There are some XML corrupt characters\");\n  err.properties = {\n    id: \"invalid_xml_characters\",\n    xtag: tag,\n    value: value,\n    offset: offset,\n    explanation: \"There are some corrupt characters for the field \".concat(tag)\n  };\n  return err;\n}\nfunction getInvalidRawXMLValueException(_ref2) {\n  var tag = _ref2.tag,\n    value = _ref2.value,\n    offset = _ref2.offset;\n  var err = new XTRenderingError(\"Non string values are not allowed for rawXML tags\");\n  err.properties = {\n    id: \"invalid_raw_xml_value\",\n    xtag: tag,\n    value: value,\n    offset: offset,\n    explanation: \"The value of the raw tag : '\".concat(tag, \"' is not a string\")\n  };\n  return err;\n}\nfunction throwExpandNotFound(options) {\n  var _options$part = options.part,\n    value = _options$part.value,\n    offset = _options$part.offset,\n    _options$id = options.id,\n    id = _options$id === void 0 ? \"raw_tag_outerxml_invalid\" : _options$id,\n    _options$message = options.message,\n    message = _options$message === void 0 ? \"Raw tag not in paragraph\" : _options$message;\n  var part = options.part;\n  var _options$explanation = options.explanation,\n    explanation = _options$explanation === void 0 ? \"The tag \\\"\".concat(value, \"\\\" is not inside a paragraph\") : _options$explanation;\n  if (typeof explanation === \"function\") {\n    explanation = explanation(part);\n  }\n  var err = new XTTemplateError(message);\n  err.properties = {\n    id: id,\n    explanation: explanation,\n    rootError: options.rootError,\n    xtag: value,\n    offset: offset,\n    postparsed: options.postparsed,\n    expandTo: options.expandTo,\n    index: options.index\n  };\n  throw err;\n}\nfunction throwRawTagShouldBeOnlyTextInParagraph(options) {\n  var err = new XTTemplateError(\"Raw tag should be the only text in paragraph\");\n  var tag = options.part.value;\n  err.properties = {\n    id: \"raw_xml_tag_should_be_only_text_in_paragraph\",\n    explanation: \"The raw tag \\\"\".concat(tag, \"\\\" should be the only text in this paragraph. This means that this tag should not be surrounded by any text or spaces.\"),\n    xtag: tag,\n    offset: options.part.offset,\n    paragraphParts: options.paragraphParts\n  };\n  throw err;\n}\nfunction getUnmatchedLoopException(part) {\n  var location = part.location,\n    offset = part.offset;\n  var t = location === \"start\" ? \"unclosed\" : \"unopened\";\n  var T = location === \"start\" ? \"Unclosed\" : \"Unopened\";\n  var err = new XTTemplateError(\"\".concat(T, \" loop\"));\n  var tag = part.value;\n  err.properties = {\n    id: \"\".concat(t, \"_loop\"),\n    explanation: \"The loop with tag \\\"\".concat(tag, \"\\\" is \").concat(t),\n    xtag: tag,\n    offset: offset\n  };\n  return err;\n}\nfunction getUnbalancedLoopException(pair, lastPair) {\n  var err = new XTTemplateError(\"Unbalanced loop tag\");\n  var lastL = lastPair[0].part.value;\n  var lastR = lastPair[1].part.value;\n  var l = pair[0].part.value;\n  var r = pair[1].part.value;\n  err.properties = {\n    id: \"unbalanced_loop_tags\",\n    explanation: \"Unbalanced loop tags {#\".concat(lastL, \"}{/\").concat(lastR, \"}{#\").concat(l, \"}{/\").concat(r, \"}\"),\n    offset: [lastPair[0].part.offset, pair[1].part.offset],\n    lastPair: {\n      left: lastPair[0].part.value,\n      right: lastPair[1].part.value\n    },\n    pair: {\n      left: pair[0].part.value,\n      right: pair[1].part.value\n    }\n  };\n  return err;\n}\nfunction getClosingTagNotMatchOpeningTag(_ref3) {\n  var tags = _ref3.tags;\n  var err = new XTTemplateError(\"Closing tag does not match opening tag\");\n  err.properties = {\n    id: \"closing_tag_does_not_match_opening_tag\",\n    explanation: \"The tag \\\"\".concat(tags[0].value, \"\\\" is closed by the tag \\\"\").concat(tags[1].value, \"\\\"\"),\n    openingtag: first(tags).value,\n    offset: [first(tags).offset, last(tags).offset],\n    closingtag: last(tags).value\n  };\n  return err;\n}\nfunction getScopeCompilationError(_ref4) {\n  var tag = _ref4.tag,\n    rootError = _ref4.rootError,\n    offset = _ref4.offset;\n  var err = new XTScopeParserError(\"Scope parser compilation failed\");\n  err.properties = {\n    id: \"scopeparser_compilation_failed\",\n    offset: offset,\n    xtag: tag,\n    explanation: \"The scope parser for the tag \\\"\".concat(tag, \"\\\" failed to compile\"),\n    rootError: rootError\n  };\n  return err;\n}\nfunction getScopeParserExecutionError(_ref5) {\n  var tag = _ref5.tag,\n    scope = _ref5.scope,\n    error = _ref5.error,\n    offset = _ref5.offset;\n  var err = new XTScopeParserError(\"Scope parser execution failed\");\n  err.properties = {\n    id: \"scopeparser_execution_failed\",\n    explanation: \"The scope parser for the tag \".concat(tag, \" failed to execute\"),\n    scope: scope,\n    offset: offset,\n    xtag: tag,\n    rootError: error\n  };\n  return err;\n}\nfunction getLoopPositionProducesInvalidXMLError(_ref6) {\n  var tag = _ref6.tag,\n    offset = _ref6.offset;\n  var err = new XTTemplateError(\"The position of the loop tags \\\"\".concat(tag, \"\\\" would produce invalid XML\"));\n  err.properties = {\n    xtag: tag,\n    id: \"loop_position_invalid\",\n    explanation: \"The tags \\\"\".concat(tag, \"\\\" are misplaced in the document, for example one of them is in a table and the other one outside the table\"),\n    offset: offset\n  };\n  return err;\n}\nfunction throwUnimplementedTagType(part, index) {\n  var errorMsg = \"Unimplemented tag type \\\"\".concat(part.type, \"\\\"\");\n  if (part.module) {\n    errorMsg += \" \\\"\".concat(part.module, \"\\\"\");\n  }\n  var err = new XTTemplateError(errorMsg);\n  err.properties = {\n    part: part,\n    index: index,\n    id: \"unimplemented_tag_type\"\n  };\n  throw err;\n}\nfunction throwMalformedXml() {\n  var err = new XTInternalError(\"Malformed xml\");\n  err.properties = {\n    explanation: \"The template contains malformed xml\",\n    id: \"malformed_xml\"\n  };\n  throw err;\n}\nfunction throwResolveBeforeCompile() {\n  var err = new XTInternalError(\"You must run `.compile()` before running `.resolveData()`\");\n  err.properties = {\n    id: \"resolve_before_compile\",\n    explanation: \"You must run `.compile()` before running `.resolveData()`\"\n  };\n  throw err;\n}\nfunction throwRenderInvalidTemplate() {\n  var err = new XTInternalError(\"You should not call .render on a document that had compilation errors\");\n  err.properties = {\n    id: \"render_on_invalid_template\",\n    explanation: \"You should not call .render on a document that had compilation errors\"\n  };\n  throw err;\n}\nfunction throwRenderTwice() {\n  var err = new XTInternalError(\"You should not call .render twice on the same docxtemplater instance\");\n  err.properties = {\n    id: \"render_twice\",\n    explanation: \"You should not call .render twice on the same docxtemplater instance\"\n  };\n  throw err;\n}\nfunction throwFileTypeNotIdentified() {\n  var err = new XTInternalError(\"The filetype for this file could not be identified, is this file corrupted ?\");\n  err.properties = {\n    id: \"filetype_not_identified\",\n    explanation: \"The filetype for this file could not be identified, is this file corrupted ?\"\n  };\n  throw err;\n}\nfunction throwXmlInvalid(content, offset) {\n  var err = new XTTemplateError(\"An XML file has invalid xml\");\n  err.properties = {\n    id: \"file_has_invalid_xml\",\n    content: content,\n    offset: offset,\n    explanation: \"The docx contains invalid XML, it is most likely corrupt\"\n  };\n  throw err;\n}\nfunction throwFileTypeNotHandled(fileType) {\n  var err = new XTInternalError(\"The filetype \\\"\".concat(fileType, \"\\\" is not handled by docxtemplater\"));\n  err.properties = {\n    id: \"filetype_not_handled\",\n    explanation: \"The file you are trying to generate is of type \\\"\".concat(fileType, \"\\\", but only docx and pptx formats are handled\"),\n    fileType: fileType\n  };\n  throw err;\n}\nmodule.exports = {\n  XTError: XTError,\n  XTTemplateError: XTTemplateError,\n  XTInternalError: XTInternalError,\n  XTScopeParserError: XTScopeParserError,\n  XTAPIVersionError: XTAPIVersionError,\n  // Remove this alias in v4\n  RenderingError: XTRenderingError,\n  XTRenderingError: XTRenderingError,\n  getClosingTagNotMatchOpeningTag: getClosingTagNotMatchOpeningTag,\n  getLoopPositionProducesInvalidXMLError: getLoopPositionProducesInvalidXMLError,\n  getScopeCompilationError: getScopeCompilationError,\n  getScopeParserExecutionError: getScopeParserExecutionError,\n  getUnclosedTagException: getUnclosedTagException,\n  getUnopenedTagException: getUnopenedTagException,\n  getUnmatchedLoopException: getUnmatchedLoopException,\n  getDuplicateCloseTagException: getDuplicateCloseTagException,\n  getDuplicateOpenTagException: getDuplicateOpenTagException,\n  getCorruptCharactersException: getCorruptCharactersException,\n  getInvalidRawXMLValueException: getInvalidRawXMLValueException,\n  getUnbalancedLoopException: getUnbalancedLoopException,\n  throwApiVersionError: throwApiVersionError,\n  throwFileTypeNotHandled: throwFileTypeNotHandled,\n  throwFileTypeNotIdentified: throwFileTypeNotIdentified,\n  throwMalformedXml: throwMalformedXml,\n  throwMultiError: throwMultiError,\n  throwExpandNotFound: throwExpandNotFound,\n  throwRawTagShouldBeOnlyTextInParagraph: throwRawTagShouldBeOnlyTextInParagraph,\n  throwUnimplementedTagType: throwUnimplementedTagType,\n  throwXmlTagNotFound: throwXmlTagNotFound,\n  throwXmlInvalid: throwXmlInvalid,\n  throwResolveBeforeCompile: throwResolveBeforeCompile,\n  throwRenderInvalidTemplate: throwRenderInvalidTemplate,\n  throwRenderTwice: throwRenderTwice\n};","\n\nfunction last(a) {\n  return a[a.length - 1];\n}\nfunction first(a) {\n  return a[0];\n}\nmodule.exports = {\n  last: last,\n  first: first\n};","\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nvar _require = require(\"./doc-utils.js\"),\n  getRightOrNull = _require.getRightOrNull,\n  getRight = _require.getRight,\n  getLeft = _require.getLeft,\n  getLeftOrNull = _require.getLeftOrNull,\n  chunkBy = _require.chunkBy,\n  isTagStart = _require.isTagStart,\n  isTagEnd = _require.isTagEnd,\n  isContent = _require.isContent,\n  last = _require.last,\n  first = _require.first;\nvar _require2 = require(\"./errors.js\"),\n  XTTemplateError = _require2.XTTemplateError,\n  throwExpandNotFound = _require2.throwExpandNotFound,\n  getLoopPositionProducesInvalidXMLError = _require2.getLoopPositionProducesInvalidXMLError;\nfunction lastTagIsOpenTag(tags, tag) {\n  if (tags.length === 0) {\n    return false;\n  }\n  var innerLastTag = last(tags).substr(1);\n  return innerLastTag.indexOf(tag) === 0;\n}\nfunction getListXmlElements(parts) {\n  /*\n  Gets the list of closing and opening tags between two texts. It doesn't take\n  into account tags that are opened then closed. Those that are closed then\n  opened are kept\n  \tExample input :\n  \t[\n  \t{\n  \t\t\"type\": \"placeholder\",\n  \t\t\"value\": \"table1\",\n  \t\t...\n  \t},\n  \t{\n  \t\t\"type\": \"placeholder\",\n  \t\t\"value\": \"t1data1\",\n  \t},\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"position\": \"end\",\n  \t\t\"text\": true,\n  \t\t\"value\": \"</w:t>\",\n  \t\t\"tag\": \"w:t\",\n  \t\t\"lIndex\": 112\n  \t},\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"value\": \"</w:r>\",\n  \t},\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"value\": \"</w:p>\",\n  \t},\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"value\": \"</w:tc>\",\n  \t},\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"value\": \"<w:tc>\",\n  \t},\n  \t{\n  \t\t\"type\": \"content\",\n  \t\t\"value\": \"<w:tcPr><w:tcW w:w=\"2444\" w:type=\"dxa\"/><w:tcBorders><w:top w:val=\"nil\"/><w:left w:val=\"nil\"/><w:bottom w:val=\"nil\"/><w:right w:val=\"nil\"/></w:tcBorders><w:shd w:val=\"clear\" w:color=\"auto\" w:fill=\"FFFFFF\"/></w:tcPr>\",\n  \t},\n  \t...\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"value\": \"<w:r>\",\n  \t},\n  \t{\n  \t\t\"type\": \"tag\",\n  \t\t\"value\": \"<w:t xml:space=\"preserve\">\",\n  \t},\n  \t{\n  \t\t\"type\": \"placeholder\",\n  \t\t\"value\": \"t1data4\",\n  \t}\n  ]\n  \treturns\n  \t[\n  \t\t{\n  \t\t\t\"tag\": \"</w:t>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"</w:r>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"</w:p>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"</w:tc>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"<w:tc>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"<w:p>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"<w:r>\",\n  \t\t},\n  \t\t{\n  \t\t\t\"tag\": \"<w:t>\",\n  \t\t},\n  \t]\n  */\n\n  var result = [];\n  for (var i = 0; i < parts.length; i++) {\n    var _parts$i = parts[i],\n      position = _parts$i.position,\n      value = _parts$i.value,\n      tag = _parts$i.tag;\n    // Stryker disable all : because removing this condition would also work but we want to make the API future proof\n    if (!tag) {\n      continue;\n    }\n    // Stryker restore all\n    if (position === \"end\") {\n      if (lastTagIsOpenTag(result, tag)) {\n        result.pop();\n      } else {\n        result.push(value);\n      }\n    } else if (position === \"start\") {\n      result.push(value);\n    }\n    // ignore position === \"selfclosing\"\n  }\n\n  return result;\n}\nfunction has(name, xmlElements) {\n  for (var i = 0; i < xmlElements.length; i++) {\n    var xmlElement = xmlElements[i];\n    if (xmlElement.indexOf(\"<\".concat(name)) === 0) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction getExpandToDefault(postparsed, pair, expandTags) {\n  var parts = postparsed.slice(pair[0].offset, pair[1].offset);\n  var xmlElements = getListXmlElements(parts);\n  var closingTagCount = xmlElements.filter(function (tag) {\n    return tag[1] === \"/\";\n  }).length;\n  var startingTagCount = xmlElements.filter(function (tag) {\n    return tag[1] !== \"/\" && tag[tag.length - 2] !== \"/\";\n  }).length;\n  if (closingTagCount !== startingTagCount) {\n    return {\n      error: getLoopPositionProducesInvalidXMLError({\n        tag: first(pair).part.value,\n        offset: [first(pair).part.offset, last(pair).part.offset]\n      })\n    };\n  }\n  var _loop = function _loop() {\n    var _expandTags$i = expandTags[i],\n      contains = _expandTags$i.contains,\n      expand = _expandTags$i.expand,\n      onlyTextInTag = _expandTags$i.onlyTextInTag;\n    if (has(contains, xmlElements)) {\n      if (onlyTextInTag) {\n        var left = getLeftOrNull(postparsed, contains, pair[0].offset);\n        var right = getRightOrNull(postparsed, contains, pair[1].offset);\n        if (left === null || right === null) {\n          return \"continue\";\n        }\n        var chunks = chunkBy(postparsed.slice(left, right), function (p) {\n          return isTagStart(contains, p) ? \"start\" : isTagEnd(contains, p) ? \"end\" : null;\n        });\n        var firstChunk = first(chunks);\n        var lastChunk = last(chunks);\n        var firstContent = firstChunk.filter(isContent);\n        var lastContent = lastChunk.filter(isContent);\n        if (firstContent.length !== 1 || lastContent.length !== 1) {\n          return \"continue\";\n        }\n      }\n      return {\n        v: {\n          value: expand\n        }\n      };\n    }\n  };\n  for (var i = 0, len = expandTags.length; i < len; i++) {\n    var _ret = _loop();\n    if (_ret === \"continue\") continue;\n    if (_typeof(_ret) === \"object\") return _ret.v;\n  }\n  return {};\n}\nfunction getExpandLimit(part, index, postparsed, options) {\n  var expandTo = part.expandTo || options.expandTo;\n  // Stryker disable all : because this condition can be removed in v4 (the only usage was the image module before version 3.12.3 of the image module\n  if (!expandTo) {\n    return;\n  }\n  // Stryker restore all\n  var right, left;\n  try {\n    left = getLeft(postparsed, expandTo, index);\n    right = getRight(postparsed, expandTo, index);\n  } catch (rootError) {\n    if (rootError instanceof XTTemplateError) {\n      throwExpandNotFound(_objectSpread({\n        part: part,\n        rootError: rootError,\n        postparsed: postparsed,\n        expandTo: expandTo,\n        index: index\n      }, options.error));\n    }\n    throw rootError;\n  }\n  return [left, right];\n}\nfunction expandOne(_ref, part, postparsed, options) {\n  var _ref2 = _slicedToArray(_ref, 2),\n    left = _ref2[0],\n    right = _ref2[1];\n  var index = postparsed.indexOf(part);\n  var leftParts = postparsed.slice(left, index);\n  var rightParts = postparsed.slice(index + 1, right + 1);\n  var inner = options.getInner({\n    postparse: options.postparse,\n    index: index,\n    part: part,\n    leftParts: leftParts,\n    rightParts: rightParts,\n    left: left,\n    right: right,\n    postparsed: postparsed\n  });\n  if (!inner.length) {\n    inner.expanded = [leftParts, rightParts];\n    inner = [inner];\n  }\n  return {\n    left: left,\n    right: right,\n    inner: inner\n  };\n}\nfunction expandToOne(postparsed, options) {\n  var errors = [];\n  if (postparsed.errors) {\n    errors = postparsed.errors;\n    postparsed = postparsed.postparsed;\n  }\n  var limits = [];\n  for (var i = 0, len = postparsed.length; i < len; i++) {\n    var part = postparsed[i];\n    if (part.type === \"placeholder\" && part.module === options.moduleName &&\n    // The part.subparsed check is used to fix this github issue :\n    // https://github.com/open-xml-templating/docxtemplater/issues/671\n    !part.subparsed) {\n      try {\n        var limit = getExpandLimit(part, i, postparsed, options);\n        if (!limit) {\n          continue;\n        }\n        var _limit = _slicedToArray(limit, 2),\n          left = _limit[0],\n          right = _limit[1];\n        limits.push({\n          left: left,\n          right: right,\n          part: part,\n          i: i,\n          leftPart: postparsed[left],\n          rightPart: postparsed[right]\n        });\n      } catch (error) {\n        if (error instanceof XTTemplateError) {\n          errors.push(error);\n        } else {\n          throw error;\n        }\n      }\n    }\n  }\n  limits.sort(function (l1, l2) {\n    if (l1.left === l2.left) {\n      return l2.part.lIndex < l1.part.lIndex ? 1 : -1;\n    }\n    return l2.left < l1.left ? 1 : -1;\n  });\n  var maxRight = -1;\n  var offset = 0;\n  limits.forEach(function (limit, i) {\n    var _postparsed;\n    maxRight = Math.max(maxRight, i > 0 ? limits[i - 1].right : 0);\n    if (limit.left < maxRight) {\n      return;\n    }\n    var result;\n    try {\n      result = expandOne([limit.left + offset, limit.right + offset], limit.part, postparsed, options);\n    } catch (error) {\n      if (error instanceof XTTemplateError) {\n        errors.push(error);\n      } else {\n        throw error;\n      }\n    }\n    if (!result) {\n      return;\n    }\n    offset += result.inner.length - (result.right + 1 - result.left);\n    (_postparsed = postparsed).splice.apply(_postparsed, [result.left, result.right + 1 - result.left].concat(_toConsumableArray(result.inner)));\n  });\n  return {\n    postparsed: postparsed,\n    errors: errors\n  };\n}\nmodule.exports = {\n  expandToOne: expandToOne,\n  getExpandToDefault: getExpandToDefault\n};","\n\nvar _require = require(\"./errors.js\"),\n  XTInternalError = _require.XTInternalError;\nfunction emptyFun() {}\nfunction identity(i) {\n  return i;\n}\nmodule.exports = function (module) {\n  var defaults = {\n    set: emptyFun,\n    matchers: function matchers() {\n      return [];\n    },\n    parse: emptyFun,\n    render: emptyFun,\n    getTraits: emptyFun,\n    getFileType: emptyFun,\n    nullGetter: emptyFun,\n    optionsTransformer: identity,\n    postrender: identity,\n    errorsTransformer: identity,\n    getRenderedMap: identity,\n    preparse: identity,\n    postparse: identity,\n    on: emptyFun,\n    resolve: emptyFun\n  };\n  if (Object.keys(defaults).every(function (key) {\n    return !module[key];\n  })) {\n    var err = new XTInternalError(\"This module cannot be wrapped, because it doesn't define any of the necessary functions\");\n    err.properties = {\n      id: \"module_cannot_be_wrapped\",\n      explanation: \"This module cannot be wrapped, because it doesn't define any of the necessary functions\"\n    };\n    throw err;\n  }\n  Object.keys(defaults).forEach(function (key) {\n    module[key] = module[key] || defaults[key];\n  });\n  return module;\n};","\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar _require = require(\"./errors.js\"),\n  getScopeParserExecutionError = _require.getScopeParserExecutionError;\nvar _require2 = require(\"./utils.js\"),\n  last = _require2.last;\nvar _require3 = require(\"./doc-utils.js\"),\n  concatArrays = _require3.concatArrays;\nfunction find(list, fn) {\n  var length = list.length >>> 0;\n  var value;\n  for (var i = 0; i < length; i++) {\n    value = list[i];\n    if (fn.call(this, value, i, list)) {\n      return value;\n    }\n  }\n  return undefined;\n}\nfunction _getValue(tag, meta, num) {\n  var _this = this;\n  var scope = this.scopeList[num];\n  if (this.root.finishedResolving) {\n    var w = this.resolved;\n    var _loop = function _loop() {\n      var lIndex = _this.scopeLindex[i];\n      w = find(w, function (r) {\n        return r.lIndex === lIndex;\n      });\n      w = w.value[_this.scopePathItem[i]];\n    };\n    for (var i = this.resolveOffset, len = this.scopePath.length; i < len; i++) {\n      _loop();\n    }\n    return find(w, function (r) {\n      return meta.part.lIndex === r.lIndex;\n    }).value;\n  }\n  // search in the scopes (in reverse order) and keep the first defined value\n  var result;\n  var parser;\n  if (!this.cachedParsers || !meta.part) {\n    parser = this.parser(tag, {\n      scopePath: this.scopePath\n    });\n  } else if (this.cachedParsers[meta.part.lIndex]) {\n    parser = this.cachedParsers[meta.part.lIndex];\n  } else {\n    parser = this.cachedParsers[meta.part.lIndex] = this.parser(tag, {\n      scopePath: this.scopePath\n    });\n  }\n  try {\n    result = parser.get(scope, this.getContext(meta, num));\n  } catch (error) {\n    throw getScopeParserExecutionError({\n      tag: tag,\n      scope: scope,\n      error: error,\n      offset: meta.part.offset\n    });\n  }\n  if (result == null && num > 0) {\n    return _getValue.call(this, tag, meta, num - 1);\n  }\n  return result;\n}\nfunction _getValueAsync(tag, meta, num) {\n  var _this2 = this;\n  var scope = this.scopeList[num];\n  // search in the scopes (in reverse order) and keep the first defined value\n  var parser;\n  if (!this.cachedParsers || !meta.part) {\n    parser = this.parser(tag, {\n      scopePath: this.scopePath\n    });\n  } else if (this.cachedParsers[meta.part.lIndex]) {\n    parser = this.cachedParsers[meta.part.lIndex];\n  } else {\n    parser = this.cachedParsers[meta.part.lIndex] = this.parser(tag, {\n      scopePath: this.scopePath\n    });\n  }\n  return Promise.resolve().then(function () {\n    return parser.get(scope, _this2.getContext(meta, num));\n  })[\"catch\"](function (error) {\n    throw getScopeParserExecutionError({\n      tag: tag,\n      scope: scope,\n      error: error,\n      offset: meta.part.offset\n    });\n  }).then(function (result) {\n    if (result == null && num > 0) {\n      return _getValueAsync.call(_this2, tag, meta, num - 1);\n    }\n    return result;\n  });\n}\nvar ScopeManager = /*#__PURE__*/function () {\n  function ScopeManager(options) {\n    _classCallCheck(this, ScopeManager);\n    this.root = options.root || this;\n    this.resolveOffset = options.resolveOffset || 0;\n    this.scopePath = options.scopePath;\n    this.scopePathItem = options.scopePathItem;\n    this.scopePathLength = options.scopePathLength;\n    this.scopeList = options.scopeList;\n    this.scopeType = \"\";\n    this.scopeTypes = options.scopeTypes;\n    this.scopeLindex = options.scopeLindex;\n    this.parser = options.parser;\n    this.resolved = options.resolved;\n    this.cachedParsers = options.cachedParsers;\n  }\n  _createClass(ScopeManager, [{\n    key: \"loopOver\",\n    value: function loopOver(tag, functor, inverted, meta) {\n      return this.loopOverValue(this.getValue(tag, meta), functor, inverted);\n    }\n  }, {\n    key: \"functorIfInverted\",\n    value: function functorIfInverted(inverted, functor, value, i, length) {\n      if (inverted) {\n        functor(value, i, length);\n      }\n      return inverted;\n    }\n  }, {\n    key: \"isValueFalsy\",\n    value: function isValueFalsy(value, type) {\n      return value == null || !value || type === \"[object Array]\" && value.length === 0;\n    }\n  }, {\n    key: \"loopOverValue\",\n    value: function loopOverValue(value, functor, inverted) {\n      if (this.root.finishedResolving) {\n        inverted = false;\n      }\n      var type = Object.prototype.toString.call(value);\n      if (this.isValueFalsy(value, type)) {\n        this.scopeType = false;\n        return this.functorIfInverted(inverted, functor, last(this.scopeList), 0, 1);\n      }\n      if (type === \"[object Array]\") {\n        this.scopeType = \"array\";\n        for (var i = 0; i < value.length; i++) {\n          this.functorIfInverted(!inverted, functor, value[i], i, value.length);\n        }\n        return true;\n      }\n      if (type === \"[object Object]\") {\n        this.scopeType = \"object\";\n        return this.functorIfInverted(!inverted, functor, value, 0, 1);\n      }\n      return this.functorIfInverted(!inverted, functor, last(this.scopeList), 0, 1);\n    }\n  }, {\n    key: \"getValue\",\n    value: function getValue(tag, meta) {\n      var result = _getValue.call(this, tag, meta, this.scopeList.length - 1);\n      if (typeof result === \"function\") {\n        return result(this.scopeList[this.scopeList.length - 1], this);\n      }\n      return result;\n    }\n  }, {\n    key: \"getValueAsync\",\n    value: function getValueAsync(tag, meta) {\n      var _this3 = this;\n      return _getValueAsync.call(this, tag, meta, this.scopeList.length - 1).then(function (result) {\n        if (typeof result === \"function\") {\n          return result(_this3.scopeList[_this3.scopeList.length - 1], _this3);\n        }\n        return result;\n      });\n    }\n  }, {\n    key: \"getContext\",\n    value: function getContext(meta, num) {\n      return {\n        num: num,\n        meta: meta,\n        scopeList: this.scopeList,\n        resolved: this.resolved,\n        scopePath: this.scopePath,\n        scopeTypes: this.scopeTypes,\n        scopePathItem: this.scopePathItem,\n        scopePathLength: this.scopePathLength\n      };\n    }\n  }, {\n    key: \"createSubScopeManager\",\n    value: function createSubScopeManager(scope, tag, i, part, length) {\n      return new ScopeManager({\n        root: this.root,\n        resolveOffset: this.resolveOffset,\n        resolved: this.resolved,\n        parser: this.parser,\n        cachedParsers: this.cachedParsers,\n        scopeTypes: concatArrays([this.scopeTypes, [this.scopeType]]),\n        scopeList: concatArrays([this.scopeList, [scope]]),\n        scopePath: concatArrays([this.scopePath, [tag]]),\n        scopePathItem: concatArrays([this.scopePathItem, [i]]),\n        scopePathLength: concatArrays([this.scopePathLength, [length]]),\n        scopeLindex: concatArrays([this.scopeLindex, [part.lIndex]])\n      });\n    }\n  }]);\n  return ScopeManager;\n}();\nmodule.exports = function (options) {\n  options.scopePath = [];\n  options.scopePathItem = [];\n  options.scopePathLength = [];\n  options.scopeTypes = [];\n  options.scopeLindex = [];\n  options.scopeList = [options.tags];\n  return new ScopeManager(options);\n};","\n\n// The error thrown here contains additional information when logged with JSON.stringify (it contains a properties object containing all suberrors).\nfunction replaceErrors(key, value) {\n  if (value instanceof Error) {\n    return Object.getOwnPropertyNames(value).concat(\"stack\").reduce(function (error, key) {\n      error[key] = value[key];\n      if (key === \"stack\") {\n        // This is used because in Firefox, stack is not an own property\n        error[key] = value[key].toString();\n      }\n      return error;\n    }, {});\n  }\n  return value;\n}\nfunction logger(error, logging) {\n  // eslint-disable-next-line no-console\n  console.log(JSON.stringify({\n    error: error\n  }, replaceErrors, logging === \"json\" ? 2 : null));\n  if (error.properties && error.properties.errors instanceof Array) {\n    var errorMessages = error.properties.errors.map(function (error) {\n      return error.properties.explanation;\n    }).join(\"\\n\");\n    // eslint-disable-next-line no-console\n    console.log(\"errorMessages\", errorMessages);\n    // errorMessages is a humanly readable message looking like this :\n    // 'The tag beginning with \"foobar\" is unopened'\n  }\n}\n\nmodule.exports = logger;","\n\nvar ctXML = \"[Content_Types].xml\";\nfunction collectContentTypes(overrides, defaults, zip) {\n  var partNames = {};\n  for (var i = 0, len = overrides.length; i < len; i++) {\n    var override = overrides[i];\n    var contentType = override.getAttribute(\"ContentType\");\n    var partName = override.getAttribute(\"PartName\").substr(1);\n    partNames[partName] = contentType;\n  }\n  var _loop = function _loop() {\n    var def = defaults[_i];\n    var contentType = def.getAttribute(\"ContentType\");\n    var extension = def.getAttribute(\"Extension\");\n    // eslint-disable-next-line no-loop-func\n    zip.file(/./).map(function (_ref) {\n      var name = _ref.name;\n      if (name.slice(name.length - extension.length) === extension && !partNames[name] && name !== ctXML) {\n        partNames[name] = contentType;\n      }\n    });\n  };\n  for (var _i = 0, _len = defaults.length; _i < _len; _i++) {\n    _loop();\n  }\n  return partNames;\n}\nmodule.exports = collectContentTypes;","\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar wrapper = require(\"../module-wrapper.js\");\nvar filetypes = require(\"../filetypes.js\");\nvar coreContentType = \"application/vnd.openxmlformats-package.core-properties+xml\";\nvar appContentType = \"application/vnd.openxmlformats-officedocument.extended-properties+xml\";\nvar customContentType = \"application/vnd.openxmlformats-officedocument.custom-properties+xml\";\nvar settingsContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml\";\nvar commonContentTypes = [settingsContentType, coreContentType, appContentType, customContentType];\nvar Common = /*#__PURE__*/function () {\n  function Common() {\n    _classCallCheck(this, Common);\n    this.name = \"Common\";\n  }\n  _createClass(Common, [{\n    key: \"getFileType\",\n    value: function getFileType(_ref) {\n      var doc = _ref.doc;\n      var invertedContentTypes = doc.invertedContentTypes;\n      if (!invertedContentTypes) {\n        return;\n      }\n      for (var j = 0, len2 = commonContentTypes.length; j < len2; j++) {\n        var ct = commonContentTypes[j];\n        if (invertedContentTypes[ct]) {\n          Array.prototype.push.apply(doc.targets, invertedContentTypes[ct]);\n        }\n      }\n      var keys = [\"docx\", \"pptx\"];\n      var ftCandidate;\n      for (var i = 0, len = keys.length; i < len; i++) {\n        var contentTypes = filetypes[keys[i]];\n        for (var _j = 0, _len = contentTypes.length; _j < _len; _j++) {\n          var _ct = contentTypes[_j];\n          if (invertedContentTypes[_ct]) {\n            for (var k = 0, _len2 = invertedContentTypes[_ct].length; k < _len2; k++) {\n              var target = invertedContentTypes[_ct][k];\n              if (doc.relsTypes[target] && [\"http://purl.oclc.org/ooxml/officeDocument/relationships/officeDocument\", \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument\"].indexOf(doc.relsTypes[target]) === -1) {\n                continue;\n              }\n              ftCandidate = keys[i];\n              if (filetypes.main.indexOf(_ct) !== -1 || _ct === filetypes.pptx[0]) {\n                doc.textTarget || (doc.textTarget = target);\n              }\n              doc.targets.push(target);\n            }\n          }\n        }\n        if (ftCandidate) {\n          return ftCandidate;\n        }\n      }\n      return ftCandidate;\n    }\n  }]);\n  return Common;\n}();\nmodule.exports = function () {\n  return wrapper(new Common());\n};","\n\nvar docxContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml\";\nvar docxmContentType = \"application/vnd.ms-word.document.macroEnabled.main+xml\";\nvar dotxContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml\";\nvar dotmContentType = \"application/vnd.ms-word.template.macroEnabledTemplate.main+xml\";\nvar headerContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.header+xml\";\nvar footnotesContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml\";\nvar footerContentType = \"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml\";\nvar pptxContentType = \"application/vnd.openxmlformats-officedocument.presentationml.slide+xml\";\nvar pptxSlideMaster = \"application/vnd.openxmlformats-officedocument.presentationml.slideMaster+xml\";\nvar pptxSlideLayout = \"application/vnd.openxmlformats-officedocument.presentationml.slideLayout+xml\";\nvar pptxPresentationContentType = \"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml\";\nvar main = [docxContentType, docxmContentType, dotxContentType, dotmContentType];\nvar filetypes = {\n  main: main,\n  docx: [headerContentType].concat(main, [footerContentType, footnotesContentType]),\n  pptx: [pptxContentType, pptxSlideMaster, pptxSlideLayout, pptxPresentationContentType]\n};\nmodule.exports = filetypes;","\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nvar _require = require(\"./errors.js\"),\n  getUnclosedTagException = _require.getUnclosedTagException,\n  getUnopenedTagException = _require.getUnopenedTagException,\n  getDuplicateOpenTagException = _require.getDuplicateOpenTagException,\n  getDuplicateCloseTagException = _require.getDuplicateCloseTagException,\n  throwMalformedXml = _require.throwMalformedXml,\n  throwXmlInvalid = _require.throwXmlInvalid,\n  XTTemplateError = _require.XTTemplateError;\nvar _require2 = require(\"./doc-utils.js\"),\n  isTextStart = _require2.isTextStart,\n  isTextEnd = _require2.isTextEnd,\n  wordToUtf8 = _require2.wordToUtf8;\nvar DELIMITER_NONE = 0,\n  DELIMITER_EQUAL = 1,\n  DELIMITER_START = 2,\n  DELIMITER_END = 3;\nfunction inRange(range, match) {\n  return range[0] <= match.offset && match.offset < range[1];\n}\nfunction updateInTextTag(part, inTextTag) {\n  if (isTextStart(part)) {\n    if (inTextTag) {\n      throwMalformedXml();\n    }\n    return true;\n  }\n  if (isTextEnd(part)) {\n    if (!inTextTag) {\n      throwMalformedXml();\n    }\n    return false;\n  }\n  return inTextTag;\n}\nfunction getTag(tag) {\n  var position = \"\";\n  var start = 1;\n  var end = tag.indexOf(\" \");\n  if (tag[tag.length - 2] === \"/\") {\n    position = \"selfclosing\";\n    if (end === -1) {\n      end = tag.length - 2;\n    }\n  } else if (tag[1] === \"/\") {\n    start = 2;\n    position = \"end\";\n    if (end === -1) {\n      end = tag.length - 1;\n    }\n  } else {\n    position = \"start\";\n    if (end === -1) {\n      end = tag.length - 1;\n    }\n  }\n  return {\n    tag: tag.slice(start, end),\n    position: position\n  };\n}\nfunction tagMatcher(content, textMatchArray, othersMatchArray) {\n  var cursor = 0;\n  var contentLength = content.length;\n  var allMatches = {};\n  for (var i = 0, len = textMatchArray.length; i < len; i++) {\n    allMatches[textMatchArray[i]] = true;\n  }\n  for (var _i = 0, _len = othersMatchArray.length; _i < _len; _i++) {\n    allMatches[othersMatchArray[_i]] = false;\n  }\n  var totalMatches = [];\n  while (cursor < contentLength) {\n    cursor = content.indexOf(\"<\", cursor);\n    if (cursor === -1) {\n      break;\n    }\n    var offset = cursor;\n    var nextOpening = content.indexOf(\"<\", cursor + 1);\n    cursor = content.indexOf(\">\", cursor);\n    if (cursor === -1 || nextOpening !== -1 && cursor > nextOpening) {\n      throwXmlInvalid(content, offset);\n    }\n    var tagText = content.slice(offset, cursor + 1);\n    var _getTag = getTag(tagText),\n      tag = _getTag.tag,\n      position = _getTag.position;\n    var text = allMatches[tag];\n    if (text == null) {\n      continue;\n    }\n    totalMatches.push({\n      type: \"tag\",\n      position: position,\n      text: text,\n      offset: offset,\n      value: tagText,\n      tag: tag\n    });\n  }\n  return totalMatches;\n}\nfunction getDelimiterErrors(delimiterMatches, fullText) {\n  var errors = [];\n  var inDelimiter = false;\n  var lastDelimiterMatch = {\n    offset: 0\n  };\n  var xtag;\n  delimiterMatches.forEach(function (delimiterMatch) {\n    xtag = fullText.substr(lastDelimiterMatch.offset, delimiterMatch.offset - lastDelimiterMatch.offset);\n    if (delimiterMatch.position === \"start\" && inDelimiter || delimiterMatch.position === \"end\" && !inDelimiter) {\n      if (delimiterMatch.position === \"start\") {\n        if (lastDelimiterMatch.offset + lastDelimiterMatch.length === delimiterMatch.offset) {\n          xtag = fullText.substr(lastDelimiterMatch.offset, delimiterMatch.offset - lastDelimiterMatch.offset + lastDelimiterMatch.length + 4);\n          errors.push(getDuplicateOpenTagException({\n            xtag: xtag,\n            offset: lastDelimiterMatch.offset\n          }));\n        } else {\n          errors.push(getUnclosedTagException({\n            xtag: wordToUtf8(xtag),\n            offset: lastDelimiterMatch.offset\n          }));\n        }\n        delimiterMatch.error = true;\n      } else {\n        if (lastDelimiterMatch.offset + lastDelimiterMatch.length === delimiterMatch.offset) {\n          xtag = fullText.substr(lastDelimiterMatch.offset - 4, delimiterMatch.offset - lastDelimiterMatch.offset + 4 + lastDelimiterMatch.length);\n          errors.push(getDuplicateCloseTagException({\n            xtag: xtag,\n            offset: lastDelimiterMatch.offset\n          }));\n        } else {\n          errors.push(getUnopenedTagException({\n            xtag: xtag,\n            offset: delimiterMatch.offset\n          }));\n        }\n        delimiterMatch.error = true;\n      }\n    } else {\n      inDelimiter = !inDelimiter;\n    }\n    lastDelimiterMatch = delimiterMatch;\n  });\n  var delimiterMatch = {\n    offset: fullText.length\n  };\n  xtag = fullText.substr(lastDelimiterMatch.offset, delimiterMatch.offset - lastDelimiterMatch.offset);\n  if (inDelimiter) {\n    errors.push(getUnclosedTagException({\n      xtag: wordToUtf8(xtag),\n      offset: lastDelimiterMatch.offset\n    }));\n    delimiterMatch.error = true;\n  }\n  return errors;\n}\nfunction compareOffsets(startOffset, endOffset) {\n  if (startOffset === -1 && endOffset === -1) {\n    return DELIMITER_NONE;\n  }\n  if (startOffset === endOffset) {\n    return DELIMITER_EQUAL;\n  }\n  if (startOffset === -1 || endOffset === -1) {\n    return endOffset < startOffset ? DELIMITER_START : DELIMITER_END;\n  }\n  return startOffset < endOffset ? DELIMITER_START : DELIMITER_END;\n}\nfunction splitDelimiters(inside) {\n  var newDelimiters = inside.split(\" \");\n  if (newDelimiters.length !== 2) {\n    var err = new XTTemplateError(\"New Delimiters cannot be parsed\");\n    err.properties = {\n      id: \"change_delimiters_invalid\",\n      explanation: \"Cannot parser delimiters\"\n    };\n    throw err;\n  }\n  var _newDelimiters = _slicedToArray(newDelimiters, 2),\n    start = _newDelimiters[0],\n    end = _newDelimiters[1];\n  if (start.length === 0 || end.length === 0) {\n    var _err = new XTTemplateError(\"New Delimiters cannot be parsed\");\n    _err.properties = {\n      id: \"change_delimiters_invalid\",\n      explanation: \"Cannot parser delimiters\"\n    };\n    throw _err;\n  }\n  return [start, end];\n}\nfunction getAllDelimiterIndexes(fullText, delimiters) {\n  var indexes = [];\n  var start = delimiters.start,\n    end = delimiters.end;\n  var offset = -1;\n  var insideTag = false;\n  while (true) {\n    var startOffset = fullText.indexOf(start, offset + 1);\n    var endOffset = fullText.indexOf(end, offset + 1);\n    var position = null;\n    var len = void 0;\n    var compareResult = compareOffsets(startOffset, endOffset);\n    if (compareResult === DELIMITER_EQUAL) {\n      compareResult = insideTag ? DELIMITER_END : DELIMITER_START;\n    }\n    switch (compareResult) {\n      case DELIMITER_NONE:\n        return indexes;\n      case DELIMITER_END:\n        insideTag = false;\n        offset = endOffset;\n        position = \"end\";\n        len = end.length;\n        break;\n      case DELIMITER_START:\n        insideTag = true;\n        offset = startOffset;\n        position = \"start\";\n        len = start.length;\n        break;\n    }\n    // if tag starts with =, such as {=[ ]=}\n    if (compareResult === DELIMITER_START && fullText[offset + start.length] === \"=\") {\n      indexes.push({\n        offset: startOffset,\n        position: \"start\",\n        length: start.length,\n        changedelimiter: true\n      });\n      var nextEqual = fullText.indexOf(\"=\", offset + start.length + 1);\n      var nextEndOffset = fullText.indexOf(end, nextEqual + 1);\n      indexes.push({\n        offset: nextEndOffset,\n        position: \"end\",\n        length: end.length,\n        changedelimiter: true\n      });\n      var _insideTag = fullText.substr(offset + start.length + 1, nextEqual - offset - start.length - 1);\n      var _splitDelimiters = splitDelimiters(_insideTag);\n      var _splitDelimiters2 = _slicedToArray(_splitDelimiters, 2);\n      start = _splitDelimiters2[0];\n      end = _splitDelimiters2[1];\n      offset = nextEndOffset;\n      continue;\n    }\n    indexes.push({\n      offset: offset,\n      position: position,\n      length: len\n    });\n  }\n}\nfunction parseDelimiters(innerContentParts, delimiters) {\n  var full = innerContentParts.map(function (p) {\n    return p.value;\n  }).join(\"\");\n  var delimiterMatches = getAllDelimiterIndexes(full, delimiters);\n  var offset = 0;\n  var ranges = innerContentParts.map(function (part) {\n    offset += part.value.length;\n    return {\n      offset: offset - part.value.length,\n      lIndex: part.lIndex\n    };\n  });\n  var errors = getDelimiterErrors(delimiterMatches, full, ranges);\n  var cutNext = 0;\n  var delimiterIndex = 0;\n  var parsed = ranges.map(function (p, i) {\n    var offset = p.offset;\n    var range = [offset, offset + innerContentParts[i].value.length];\n    var partContent = innerContentParts[i].value;\n    var delimitersInOffset = [];\n    while (delimiterIndex < delimiterMatches.length && inRange(range, delimiterMatches[delimiterIndex])) {\n      delimitersInOffset.push(delimiterMatches[delimiterIndex]);\n      delimiterIndex++;\n    }\n    var parts = [];\n    var cursor = 0;\n    if (cutNext > 0) {\n      cursor = cutNext;\n      cutNext = 0;\n    }\n    delimitersInOffset.forEach(function (delimiterInOffset) {\n      var value = partContent.substr(cursor, delimiterInOffset.offset - offset - cursor);\n      if (delimiterInOffset.changedelimiter) {\n        if (delimiterInOffset.position === \"start\") {\n          if (value.length > 0) {\n            parts.push({\n              type: \"content\",\n              value: value\n            });\n          }\n        } else {\n          cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n        }\n        return;\n      }\n      if (value.length > 0) {\n        parts.push({\n          type: \"content\",\n          value: value\n        });\n        cursor += value.length;\n      }\n      var delimiterPart = {\n        type: \"delimiter\",\n        position: delimiterInOffset.position,\n        offset: cursor + offset\n      };\n      parts.push(delimiterPart);\n      cursor = delimiterInOffset.offset - offset + delimiterInOffset.length;\n    });\n    cutNext = cursor - partContent.length;\n    var value = partContent.substr(cursor);\n    if (value.length > 0) {\n      parts.push({\n        type: \"content\",\n        value: value\n      });\n    }\n    return parts;\n  }, this);\n  return {\n    parsed: parsed,\n    errors: errors\n  };\n}\nfunction isInsideContent(part) {\n  // Stryker disable all : because the part.position === \"insidetag\" would be enough but we want to make the API future proof\n  return part.type === \"content\" && part.position === \"insidetag\";\n  // Stryker restore all\n}\n\nfunction getContentParts(xmlparsed) {\n  return xmlparsed.filter(isInsideContent);\n}\nfunction decodeContentParts(xmlparsed) {\n  var inTextTag = false;\n  xmlparsed.forEach(function (part) {\n    inTextTag = updateInTextTag(part, inTextTag);\n    if (part.type === \"content\") {\n      part.position = inTextTag ? \"insidetag\" : \"outsidetag\";\n    }\n    if (isInsideContent(part)) {\n      part.value = part.value.replace(/>/g, \"&gt;\");\n    }\n  });\n}\nmodule.exports = {\n  parseDelimiters: parseDelimiters,\n  parse: function parse(xmlparsed, delimiters) {\n    decodeContentParts(xmlparsed);\n    var _parseDelimiters = parseDelimiters(getContentParts(xmlparsed), delimiters),\n      delimiterParsed = _parseDelimiters.parsed,\n      errors = _parseDelimiters.errors;\n    var lexed = [];\n    var index = 0;\n    var lIndex = 0;\n    xmlparsed.forEach(function (part) {\n      if (isInsideContent(part)) {\n        Array.prototype.push.apply(lexed, delimiterParsed[index].map(function (p) {\n          if (p.type === \"content\") {\n            p.position = \"insidetag\";\n          }\n          p.lIndex = lIndex++;\n          return p;\n        }));\n        index++;\n      } else {\n        part.lIndex = lIndex++;\n        lexed.push(part);\n      }\n    });\n    return {\n      errors: errors,\n      lexed: lexed\n    };\n  },\n  xmlparse: function xmlparse(content, xmltags) {\n    var matches = tagMatcher(content, xmltags.text, xmltags.other);\n    var cursor = 0;\n    var parsed = matches.reduce(function (parsed, match) {\n      var value = content.substr(cursor, match.offset - cursor);\n      if (value.length > 0) {\n        parsed.push({\n          type: \"content\",\n          value: value\n        });\n      }\n      cursor = match.offset + match.value.length;\n      delete match.offset;\n      parsed.push(match);\n      return parsed;\n    }, []);\n    var value = content.substr(cursor);\n    if (value.length > 0) {\n      parsed.push({\n        type: \"content\",\n        value: value\n      });\n    }\n    return parsed;\n  }\n};","\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar _require = require(\"./doc-utils.js\"),\n  wordToUtf8 = _require.wordToUtf8,\n  convertSpaces = _require.convertSpaces;\nvar xmlMatcher = require(\"./xml-matcher.js\");\nvar Lexer = require(\"./lexer.js\");\nvar Parser = require(\"./parser.js\");\nvar _render = require(\"./render.js\");\nvar postrender = require(\"./postrender.js\");\nvar resolve = require(\"./resolve.js\");\nvar joinUncorrupt = require(\"./join-uncorrupt.js\");\nfunction _getFullText(content, tagsXmlArray) {\n  var matcher = xmlMatcher(content, tagsXmlArray);\n  var result = matcher.matches.map(function (match) {\n    return match.array[2];\n  });\n  return wordToUtf8(convertSpaces(result.join(\"\")));\n}\nmodule.exports = /*#__PURE__*/function () {\n  function XmlTemplater(content, options) {\n    var _this = this;\n    _classCallCheck(this, XmlTemplater);\n    this.cachedParsers = {};\n    this.content = content;\n    Object.keys(options).forEach(function (key) {\n      _this[key] = options[key];\n    });\n    this.setModules({\n      inspect: {\n        filePath: options.filePath\n      }\n    });\n  }\n  _createClass(XmlTemplater, [{\n    key: \"resolveTags\",\n    value: function resolveTags(tags) {\n      var _this2 = this;\n      this.tags = tags;\n      var options = this.getOptions();\n      var filePath = this.filePath;\n      options.scopeManager = this.scopeManager;\n      options.resolve = resolve;\n      return resolve(options).then(function (_ref) {\n        var resolved = _ref.resolved,\n          errors = _ref.errors;\n        errors.forEach(function (error) {\n          // error properties might not be defined if some foreign error\n          // (unhandled error not thrown by docxtemplater willingly) is\n          // thrown.\n          error.properties = error.properties || {};\n          error.properties.file = filePath;\n        });\n        if (errors.length !== 0) {\n          throw errors;\n        }\n        return Promise.all(resolved).then(function (resolved) {\n          options.scopeManager.root.finishedResolving = true;\n          options.scopeManager.resolved = resolved;\n          _this2.setModules({\n            inspect: {\n              resolved: resolved,\n              filePath: filePath\n            }\n          });\n          return resolved;\n        });\n      });\n    }\n  }, {\n    key: \"getFullText\",\n    value: function getFullText() {\n      return _getFullText(this.content, this.fileTypeConfig.tagsXmlTextArray);\n    }\n  }, {\n    key: \"setModules\",\n    value: function setModules(obj) {\n      this.modules.forEach(function (module) {\n        module.set(obj);\n      });\n    }\n  }, {\n    key: \"preparse\",\n    value: function preparse() {\n      this.allErrors = [];\n      this.xmllexed = Lexer.xmlparse(this.content, {\n        text: this.fileTypeConfig.tagsXmlTextArray,\n        other: this.fileTypeConfig.tagsXmlLexedArray\n      });\n      this.setModules({\n        inspect: {\n          xmllexed: this.xmllexed\n        }\n      });\n      var _Lexer$parse = Lexer.parse(this.xmllexed, this.delimiters),\n        lexed = _Lexer$parse.lexed,\n        lexerErrors = _Lexer$parse.errors;\n      this.allErrors = this.allErrors.concat(lexerErrors);\n      this.lexed = lexed;\n      this.setModules({\n        inspect: {\n          lexed: this.lexed\n        }\n      });\n      var options = this.getOptions();\n      Parser.preparse(this.lexed, this.modules, options);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse() {\n      this.setModules({\n        inspect: {\n          filePath: this.filePath\n        }\n      });\n      var options = this.getOptions();\n      this.parsed = Parser.parse(this.lexed, this.modules, options);\n      this.setModules({\n        inspect: {\n          parsed: this.parsed\n        }\n      });\n      var _Parser$postparse = Parser.postparse(this.parsed, this.modules, options),\n        postparsed = _Parser$postparse.postparsed,\n        postparsedErrors = _Parser$postparse.errors;\n      this.postparsed = postparsed;\n      this.setModules({\n        inspect: {\n          postparsed: this.postparsed\n        }\n      });\n      this.allErrors = this.allErrors.concat(postparsedErrors);\n      this.errorChecker(this.allErrors);\n      return this;\n    }\n  }, {\n    key: \"errorChecker\",\n    value: function errorChecker(errors) {\n      var _this3 = this;\n      errors.forEach(function (error) {\n        // error properties might not be defined if some foreign\n        // (unhandled error not thrown by docxtemplater willingly) is\n        // thrown.\n        error.properties = error.properties || {};\n        error.properties.file = _this3.filePath;\n      });\n      this.modules.forEach(function (module) {\n        errors = module.errorsTransformer(errors);\n      });\n    }\n  }, {\n    key: \"baseNullGetter\",\n    value: function baseNullGetter(part, sm) {\n      var _this4 = this;\n      var value = this.modules.reduce(function (value, module) {\n        if (value != null) {\n          return value;\n        }\n        return module.nullGetter(part, sm, _this4);\n      }, null);\n      if (value != null) {\n        return value;\n      }\n      return this.nullGetter(part, sm);\n    }\n  }, {\n    key: \"getOptions\",\n    value: function getOptions() {\n      return {\n        compiled: this.postparsed,\n        cachedParsers: this.cachedParsers,\n        tags: this.tags,\n        modules: this.modules,\n        parser: this.parser,\n        contentType: this.contentType,\n        relsType: this.relsType,\n        baseNullGetter: this.baseNullGetter.bind(this),\n        filePath: this.filePath,\n        fileTypeConfig: this.fileTypeConfig,\n        fileType: this.fileType,\n        linebreaks: this.linebreaks\n      };\n    }\n  }, {\n    key: \"render\",\n    value: function render(to) {\n      this.filePath = to;\n      var options = this.getOptions();\n      options.resolved = this.scopeManager.resolved;\n      options.scopeManager = this.scopeManager;\n      options.render = _render;\n      options.joinUncorrupt = joinUncorrupt;\n      var _render2 = _render(options),\n        errors = _render2.errors,\n        parts = _render2.parts;\n      if (errors.length > 0) {\n        this.allErrors = errors;\n        this.errorChecker(errors);\n        return this;\n      }\n      this.content = postrender(parts, options);\n      this.setModules({\n        inspect: {\n          content: this.content\n        }\n      });\n      return this;\n    }\n  }]);\n  return XmlTemplater;\n}();","\n\nvar _require = require(\"./doc-utils.js\"),\n  pregMatchAll = _require.pregMatchAll;\nmodule.exports = function xmlMatcher(content, tagsXmlArray) {\n  var res = {\n    content: content\n  };\n  var taj = tagsXmlArray.join(\"|\");\n  var regexp = new RegExp(\"(?:(<(?:\".concat(taj, \")[^>]*>)([^<>]*)</(?:\").concat(taj, \")>)|(<(?:\").concat(taj, \")[^>]*/>)\"), \"g\");\n  res.matches = pregMatchAll(regexp, res.content);\n  return res;\n};","\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nvar _require = require(\"./doc-utils.js\"),\n  wordToUtf8 = _require.wordToUtf8;\nvar _require2 = require(\"./prefix-matcher.js\"),\n  match = _require2.match,\n  getValue = _require2.getValue,\n  getValues = _require2.getValues;\nfunction getMatchers(modules, options) {\n  var matchers = [];\n  for (var i = 0, l = modules.length; i < l; i++) {\n    var _module = modules[i];\n    if (_module.matchers) {\n      var mmm = _module.matchers(options);\n      if (!(mmm instanceof Array)) {\n        throw new Error(\"module matcher returns a non array\");\n      }\n      matchers.push.apply(matchers, _toConsumableArray(mmm));\n    }\n  }\n  return matchers;\n}\nfunction getMatches(matchers, placeHolderContent, options) {\n  var matches = [];\n  for (var i = 0, len = matchers.length; i < len; i++) {\n    var matcher = matchers[i];\n    var _matcher = _slicedToArray(matcher, 2),\n      prefix = _matcher[0],\n      _module2 = _matcher[1];\n    var properties = matcher[2] || {};\n    if (options.match(prefix, placeHolderContent)) {\n      var values = options.getValues(prefix, placeHolderContent);\n      if (typeof properties === \"function\") {\n        properties = properties(values);\n      }\n      if (!properties.value) {\n        var _values = _slicedToArray(values, 2);\n        properties.value = _values[1];\n      }\n      matches.push(_objectSpread({\n        type: \"placeholder\",\n        prefix: prefix,\n        module: _module2,\n        onMatch: properties.onMatch,\n        priority: properties.priority\n      }, properties));\n    }\n  }\n  return matches;\n}\nfunction moduleParse(placeHolderContent, options) {\n  var modules = options.modules;\n  var startOffset = options.startOffset;\n  var endLindex = options.lIndex;\n  var moduleParsed;\n  options.offset = startOffset;\n  options.match = match;\n  options.getValue = getValue;\n  options.getValues = getValues;\n  var matchers = getMatchers(modules, options);\n  var matches = getMatches(matchers, placeHolderContent, options);\n  if (matches.length > 0) {\n    var bestMatch = null;\n    matches.forEach(function (match) {\n      match.priority = match.priority || -match.value.length;\n      if (!bestMatch || match.priority > bestMatch.priority) {\n        bestMatch = match;\n      }\n    });\n    bestMatch.offset = startOffset;\n    delete bestMatch.priority;\n    bestMatch.endLindex = endLindex;\n    bestMatch.lIndex = endLindex;\n    bestMatch.raw = placeHolderContent;\n    if (bestMatch.onMatch) {\n      bestMatch.onMatch(bestMatch);\n    }\n    delete bestMatch.onMatch;\n    delete bestMatch.prefix;\n    return bestMatch;\n  }\n  for (var i = 0, l = modules.length; i < l; i++) {\n    var _module3 = modules[i];\n    moduleParsed = _module3.parse(placeHolderContent, options);\n    if (moduleParsed) {\n      moduleParsed.offset = startOffset;\n      moduleParsed.endLindex = endLindex;\n      moduleParsed.lIndex = endLindex;\n      moduleParsed.raw = placeHolderContent;\n      return moduleParsed;\n    }\n  }\n  return {\n    type: \"placeholder\",\n    value: placeHolderContent,\n    offset: startOffset,\n    endLindex: endLindex,\n    lIndex: endLindex\n  };\n}\nvar parser = {\n  preparse: function preparse(parsed, modules, options) {\n    function preparse(parsed, options) {\n      return modules.forEach(function (module) {\n        module.preparse(parsed, options);\n      });\n    }\n    return {\n      preparsed: preparse(parsed, options)\n    };\n  },\n  parse: function parse(lexed, modules, options) {\n    var inPlaceHolder = false;\n    var placeHolderContent = \"\";\n    var startOffset;\n    var tailParts = [];\n    var droppedTags = options.fileTypeConfig.droppedTagsInsidePlaceholder || [];\n    return lexed.reduce(function lexedToParsed(parsed, token) {\n      if (token.type === \"delimiter\") {\n        inPlaceHolder = token.position === \"start\";\n        if (token.position === \"end\") {\n          options.parse = function (placeHolderContent) {\n            return moduleParse(placeHolderContent, _objectSpread(_objectSpread(_objectSpread({}, options), token), {}, {\n              startOffset: startOffset,\n              modules: modules\n            }));\n          };\n          parsed.push(options.parse(wordToUtf8(placeHolderContent)));\n          Array.prototype.push.apply(parsed, tailParts);\n          tailParts = [];\n        }\n        if (token.position === \"start\") {\n          tailParts = [];\n          startOffset = token.offset;\n        }\n        placeHolderContent = \"\";\n        return parsed;\n      }\n      if (!inPlaceHolder) {\n        parsed.push(token);\n        return parsed;\n      }\n      if (token.type !== \"content\" || token.position !== \"insidetag\") {\n        if (droppedTags.indexOf(token.tag) !== -1) {\n          return parsed;\n        }\n        tailParts.push(token);\n        return parsed;\n      }\n      placeHolderContent += token.value;\n      return parsed;\n    }, []);\n  },\n  postparse: function postparse(postparsed, modules, options) {\n    function getTraits(traitName, postparsed) {\n      return modules.map(function (module) {\n        return module.getTraits(traitName, postparsed);\n      });\n    }\n    var errors = [];\n    function _postparse(postparsed, options) {\n      return modules.reduce(function (postparsed, module) {\n        var r = module.postparse(postparsed, _objectSpread(_objectSpread({}, options), {}, {\n          postparse: function postparse(parsed, opts) {\n            return _postparse(parsed, _objectSpread(_objectSpread({}, options), opts));\n          },\n          getTraits: getTraits\n        }));\n        if (r == null) {\n          return postparsed;\n        }\n        if (r.errors) {\n          Array.prototype.push.apply(errors, r.errors);\n          return r.postparsed;\n        }\n        return r;\n      }, postparsed);\n    }\n    return {\n      postparsed: _postparse(postparsed, options),\n      errors: errors\n    };\n  }\n};\nmodule.exports = parser;","\n\nvar nbspRegex = new RegExp(String.fromCharCode(160), \"g\");\nfunction replaceNbsps(str) {\n  return str.replace(nbspRegex, \" \");\n}\nfunction match(condition, placeHolderContent) {\n  if (typeof condition === \"string\") {\n    return replaceNbsps(placeHolderContent.substr(0, condition.length)) === condition;\n  }\n  if (condition instanceof RegExp) {\n    return condition.test(replaceNbsps(placeHolderContent));\n  }\n}\nfunction getValue(condition, placeHolderContent) {\n  if (typeof condition === \"string\") {\n    return replaceNbsps(placeHolderContent).substr(condition.length);\n  }\n  if (condition instanceof RegExp) {\n    return replaceNbsps(placeHolderContent).match(condition)[1];\n  }\n}\nfunction getValues(condition, placeHolderContent) {\n  if (typeof condition === \"string\") {\n    return [placeHolderContent, replaceNbsps(placeHolderContent).substr(condition.length)];\n  }\n  if (condition instanceof RegExp) {\n    return replaceNbsps(placeHolderContent).match(condition);\n  }\n}\nmodule.exports = {\n  match: match,\n  getValue: getValue,\n  getValues: getValues\n};","\n\nvar _require = require(\"./errors.js\"),\n  throwUnimplementedTagType = _require.throwUnimplementedTagType;\nfunction moduleRender(part, options) {\n  var moduleRendered;\n  for (var i = 0, l = options.modules.length; i < l; i++) {\n    var _module = options.modules[i];\n    moduleRendered = _module.render(part, options);\n    if (moduleRendered) {\n      return moduleRendered;\n    }\n  }\n  return false;\n}\nfunction render(options) {\n  var baseNullGetter = options.baseNullGetter;\n  var compiled = options.compiled,\n    scopeManager = options.scopeManager;\n  options.nullGetter = function (part, sm) {\n    return baseNullGetter(part, sm || scopeManager);\n  };\n  var errors = [];\n  var parts = compiled.map(function (part, i) {\n    options.index = i;\n    var moduleRendered = moduleRender(part, options);\n    if (moduleRendered) {\n      if (moduleRendered.errors) {\n        Array.prototype.push.apply(errors, moduleRendered.errors);\n      }\n      return moduleRendered;\n    }\n    if (part.type === \"content\" || part.type === \"tag\") {\n      return part;\n    }\n    throwUnimplementedTagType(part, i);\n  }).reduce(function (parts, _ref) {\n    var value = _ref.value;\n    if (value instanceof Array) {\n      for (var i = 0, len = value.length; i < len; i++) {\n        parts.push(value[i]);\n      }\n    } else if (value) {\n      parts.push(value);\n    }\n    return parts;\n  }, []);\n  return {\n    errors: errors,\n    parts: parts\n  };\n}\nmodule.exports = render;","\n\n// convert string to array (typed, when possible)\n// Stryker disable all : because this is a utility function that was copied\n// from\n// https://github.com/open-xml-templating/pizzip/blob/34a840553c604980859dc6d0dcd1f89b6e5527b3/es6/utf8.js#L33\n// eslint-disable-next-line complexity\nfunction string2buf(str) {\n  var c,\n    c2,\n    mPos,\n    i,\n    bufLen = 0;\n  var strLen = str.length;\n\n  // count binary size\n  for (mPos = 0; mPos < strLen; mPos++) {\n    c = str.charCodeAt(mPos);\n    if ((c & 0xfc00) === 0xd800 && mPos + 1 < strLen) {\n      c2 = str.charCodeAt(mPos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n        mPos++;\n      }\n    }\n    bufLen += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  var buf = new Uint8Array(bufLen);\n\n  // convert\n  for (i = 0, mPos = 0; i < bufLen; mPos++) {\n    c = str.charCodeAt(mPos);\n    if ((c & 0xfc00) === 0xd800 && mPos + 1 < strLen) {\n      c2 = str.charCodeAt(mPos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + (c - 0xd800 << 10) + (c2 - 0xdc00);\n        mPos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xc0 | c >>> 6;\n      buf[i++] = 0x80 | c & 0x3f;\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xe0 | c >>> 12;\n      buf[i++] = 0x80 | c >>> 6 & 0x3f;\n      buf[i++] = 0x80 | c & 0x3f;\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | c >>> 18;\n      buf[i++] = 0x80 | c >>> 12 & 0x3f;\n      buf[i++] = 0x80 | c >>> 6 & 0x3f;\n      buf[i++] = 0x80 | c & 0x3f;\n    }\n  }\n  return buf;\n}\n// Stryker restore all\n\nfunction postrender(parts, options) {\n  for (var i = 0, l = options.modules.length; i < l; i++) {\n    var _module = options.modules[i];\n    parts = _module.postrender(parts, options);\n  }\n  var fullLength = 0;\n  var newParts = options.joinUncorrupt(parts, options);\n  var longStr = \"\";\n  var lenStr = 0;\n  var maxCompact = 65536;\n  var uintArrays = [];\n  for (var _i = 0, len = newParts.length; _i < len; _i++) {\n    var part = newParts[_i];\n\n    // This condition should be hit in the integration test at :\n    // it(\"should not regress with long file (hit maxCompact value of 65536)\", function () {\n    // Stryker disable all : because this is an optimisation that won't make any tests fail\n    if (part.length + lenStr > maxCompact) {\n      var _arr = string2buf(longStr);\n      fullLength += _arr.length;\n      uintArrays.push(_arr);\n      longStr = \"\";\n    }\n    // Stryker restore all\n\n    longStr += part;\n    lenStr += part.length;\n    delete newParts[_i];\n  }\n  var arr = string2buf(longStr);\n  fullLength += arr.length;\n  uintArrays.push(arr);\n  var array = new Uint8Array(fullLength);\n  var j = 0;\n\n  // Stryker disable all : because this is an optimisation that won't make any tests fail\n  uintArrays.forEach(function (buf) {\n    for (var _i2 = 0; _i2 < buf.length; ++_i2) {\n      array[_i2 + j] = buf[_i2];\n    }\n    j += buf.length;\n  });\n  // Stryker restore all\n  return array;\n}\nmodule.exports = postrender;","\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction moduleResolve(part, options) {\n  var moduleResolved;\n  for (var i = 0, l = options.modules.length; i < l; i++) {\n    var _module = options.modules[i];\n    moduleResolved = _module.resolve(part, options);\n    if (moduleResolved) {\n      return moduleResolved;\n    }\n  }\n  return false;\n}\nfunction resolve(options) {\n  var resolved = [];\n  var baseNullGetter = options.baseNullGetter;\n  var compiled = options.compiled,\n    scopeManager = options.scopeManager;\n  options.nullGetter = function (part, sm) {\n    return baseNullGetter(part, sm || scopeManager);\n  };\n  options.resolved = resolved;\n  var errors = [];\n  return Promise.all(compiled.filter(function (part) {\n    return [\"content\", \"tag\"].indexOf(part.type) === -1;\n  }).reduce(function (promises, part) {\n    var moduleResolved = moduleResolve(part, options);\n    var result;\n    if (moduleResolved) {\n      result = moduleResolved.then(function (value) {\n        resolved.push({\n          tag: part.value,\n          lIndex: part.lIndex,\n          value: value\n        });\n      });\n    } else if (part.type === \"placeholder\") {\n      result = scopeManager.getValueAsync(part.value, {\n        part: part\n      }).then(function (value) {\n        return value == null ? options.nullGetter(part) : value;\n      }).then(function (value) {\n        resolved.push({\n          tag: part.value,\n          lIndex: part.lIndex,\n          value: value\n        });\n        return value;\n      });\n    } else {\n      return;\n    }\n    promises.push(result[\"catch\"](function (e) {\n      if (e instanceof Array) {\n        errors.push.apply(errors, _toConsumableArray(e));\n      } else {\n        errors.push(e);\n      }\n    }));\n    return promises;\n  }, [])).then(function () {\n    return {\n      errors: errors,\n      resolved: resolved\n    };\n  });\n}\nmodule.exports = resolve;","\n\nvar _require = require(\"./doc-utils.js\"),\n  startsWith = _require.startsWith,\n  endsWith = _require.endsWith,\n  isStarting = _require.isStarting,\n  isEnding = _require.isEnding,\n  isWhiteSpace = _require.isWhiteSpace;\nvar filetypes = require(\"./filetypes.js\");\nfunction addEmptyParagraphAfterTable(parts) {\n  var lastNonEmpty = \"\";\n  for (var i = 0, len = parts.length; i < len; i++) {\n    var p = parts[i];\n    if (isWhiteSpace(p)) {\n      continue;\n    }\n    if (endsWith(lastNonEmpty, \"</w:tbl>\")) {\n      if (!startsWith(p, \"<w:p\") && !startsWith(p, \"<w:tbl\") && !startsWith(p, \"<w:sectPr\")) {\n        p = \"<w:p/>\".concat(p);\n      }\n    }\n    lastNonEmpty = p;\n    parts[i] = p;\n  }\n  return parts;\n}\n\n// eslint-disable-next-line complexity\nfunction joinUncorrupt(parts, options) {\n  var contains = options.fileTypeConfig.tagShouldContain || [];\n  /* Before doing this \"uncorruption\" method here, this was done with the\n   * `part.emptyValue` trick, however, there were some corruptions that were\n   * not handled, for example with a template like this :\n   *\n   * ------------------------------------------------\n   * | {-w:p falsy}My para{/falsy}   |              |\n   * | {-w:p falsy}My para{/falsy}   |              |\n   */\n  var collecting = \"\";\n  var currentlyCollecting = -1;\n  if (filetypes.docx.indexOf(options.contentType) !== -1) {\n    parts = addEmptyParagraphAfterTable(parts);\n  }\n  var startIndex = -1;\n  for (var i = 0, len = parts.length; i < len; i++) {\n    var part = parts[i];\n    for (var j = 0, len2 = contains.length; j < len2; j++) {\n      var _contains$j = contains[j],\n        tag = _contains$j.tag,\n        shouldContain = _contains$j.shouldContain,\n        value = _contains$j.value,\n        drop = _contains$j.drop;\n      if (currentlyCollecting === j) {\n        if (isEnding(part, tag)) {\n          currentlyCollecting = -1;\n          if (drop) {\n            for (var k = startIndex; k <= i; k++) {\n              parts[k] = \"\";\n            }\n          } else {\n            for (var _k = startIndex; _k < i; _k++) {\n              parts[_k] = \"\";\n            }\n            parts[i] = collecting + value + part;\n          }\n          break;\n        }\n        collecting += part;\n        for (var _k2 = 0, len3 = shouldContain.length; _k2 < len3; _k2++) {\n          var sc = shouldContain[_k2];\n          if (isStarting(part, sc)) {\n            currentlyCollecting = -1;\n            // parts[i] = collecting;\n            break;\n          }\n        }\n        if (currentlyCollecting > -1) {\n          // parts[i] = \"\";\n        }\n        break;\n      }\n      if (currentlyCollecting === -1 && isStarting(part, tag) &&\n      // to verify that the part doesn't have multiple tags, such as <w:tc><w:p>\n      part.substr(1).indexOf(\"<\") === -1) {\n        // self-closing tag such as <w:t/>\n        if (part[part.length - 2] === \"/\") {\n          parts[i] = \"\";\n          break;\n        } else {\n          startIndex = i;\n          currentlyCollecting = j;\n          collecting = part;\n          // parts[i] = \"\";\n          break;\n        }\n      }\n    }\n  }\n  return parts;\n}\nmodule.exports = joinUncorrupt;","\n\nvar loopModule = require(\"./modules/loop.js\");\nvar spacePreserveModule = require(\"./modules/space-preserve.js\");\nvar rawXmlModule = require(\"./modules/rawxml.js\");\nvar expandPairTrait = require(\"./modules/expand-pair-trait.js\");\nvar render = require(\"./modules/render.js\");\nfunction DocXFileTypeConfig() {\n  return {\n    getTemplatedFiles: function getTemplatedFiles() {\n      return [];\n    },\n    textPath: function textPath(doc) {\n      return doc.textTarget;\n    },\n    tagsXmlTextArray: [\"Company\", \"HyperlinkBase\", \"Manager\", \"cp:category\", \"cp:keywords\", \"dc:creator\", \"dc:description\", \"dc:subject\", \"dc:title\", \"cp:contentStatus\", \"w:t\", \"m:t\", \"vt:lpstr\", \"vt:lpwstr\"],\n    tagsXmlLexedArray: [\"w:proofState\", \"w:tc\", \"w:tr\", \"w:tbl\", \"w:body\", \"w:document\", \"w:p\", \"w:r\", \"w:br\", \"w:rPr\", \"w:pPr\", \"w:spacing\", \"w:sdtContent\", \"w:drawing\", \"w:sectPr\", \"w:type\", \"w:headerReference\", \"w:footerReference\", \"w:bookmarkStart\", \"w:bookmarkEnd\", \"w:commentRangeStart\", \"w:commentRangeEnd\", \"w:commentReference\"],\n    droppedTagsInsidePlaceholder: [\"w:p\", \"w:br\", \"w:bookmarkStart\", \"w:bookmarkEnd\"],\n    expandTags: [{\n      contains: \"w:tc\",\n      expand: \"w:tr\"\n    }],\n    onParagraphLoop: [{\n      contains: \"w:p\",\n      expand: \"w:p\",\n      onlyTextInTag: true\n    }],\n    tagRawXml: \"w:p\",\n    baseModules: [loopModule, spacePreserveModule, expandPairTrait, rawXmlModule, render],\n    tagShouldContain: [{\n      tag: \"w:tbl\",\n      shouldContain: [\"w:tr\"],\n      drop: true\n    }, {\n      tag: \"w:tc\",\n      shouldContain: [\"w:p\"],\n      value: \"<w:p></w:p>\"\n    }, {\n      tag: \"w:sdtContent\",\n      shouldContain: [\"w:p\", \"w:r\", \"w:commentRangeStart\"],\n      value: \"<w:p></w:p>\"\n    }]\n  };\n}\nfunction PptXFileTypeConfig() {\n  return {\n    getTemplatedFiles: function getTemplatedFiles() {\n      return [];\n    },\n    textPath: function textPath(doc) {\n      return doc.textTarget;\n    },\n    tagsXmlTextArray: [\"Company\", \"HyperlinkBase\", \"Manager\", \"cp:category\", \"cp:keywords\", \"dc:creator\", \"dc:description\", \"dc:subject\", \"dc:title\", \"a:t\", \"m:t\", \"vt:lpstr\", \"vt:lpwstr\"],\n    tagsXmlLexedArray: [\"p:sp\", \"a:tc\", \"a:tr\", \"a:tbl\", \"a:p\", \"a:r\", \"a:rPr\", \"p:txBody\", \"a:txBody\", \"a:off\", \"a:ext\", \"p:graphicFrame\", \"p:xfrm\", \"a16:rowId\", \"a:endParaRPr\"],\n    droppedTagsInsidePlaceholder: [\"a:p\", \"a:endParaRPr\"],\n    expandTags: [{\n      contains: \"a:tc\",\n      expand: \"a:tr\"\n    }],\n    onParagraphLoop: [{\n      contains: \"a:p\",\n      expand: \"a:p\",\n      onlyTextInTag: true\n    }],\n    tagRawXml: \"p:sp\",\n    baseModules: [loopModule, expandPairTrait, rawXmlModule, render],\n    tagShouldContain: [{\n      tag: \"a:tbl\",\n      shouldContain: [\"a:tr\"],\n      drop: true\n    }, {\n      tag: \"p:txBody\",\n      shouldContain: [\"a:p\"],\n      value: \"<a:p></a:p>\"\n    }, {\n      tag: \"a:txBody\",\n      shouldContain: [\"a:p\"],\n      value: \"<a:p></a:p>\"\n    }]\n  };\n}\nmodule.exports = {\n  docx: DocXFileTypeConfig,\n  pptx: PptXFileTypeConfig\n};","\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }\nfunction _iterableToArrayLimit(arr, i) { var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (null != _i) { var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1; try { if (_x = (_i = _i.call(arr)).next, 0 === i) { if (Object(_i) !== _i) return; _n = !1; } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0); } catch (err) { _d = !0, _e = err; } finally { try { if (!_n && null != _i[\"return\"] && (_r = _i[\"return\"](), Object(_r) !== _r)) return; } finally { if (_d) throw _e; } } return _arr; } }\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar _require = require(\"../doc-utils.js\"),\n  chunkBy = _require.chunkBy,\n  last = _require.last,\n  isParagraphStart = _require.isParagraphStart,\n  isModule = _require.isModule,\n  isParagraphEnd = _require.isParagraphEnd,\n  isContent = _require.isContent,\n  startsWith = _require.startsWith,\n  isTagEnd = _require.isTagEnd,\n  isTagStart = _require.isTagStart,\n  getSingleAttribute = _require.getSingleAttribute,\n  setSingleAttribute = _require.setSingleAttribute;\nvar filetypes = require(\"../filetypes.js\");\nvar wrapper = require(\"../module-wrapper.js\");\nvar moduleName = \"loop\";\nfunction hasContent(parts) {\n  return parts.some(function (part) {\n    return isContent(part);\n  });\n}\nfunction getFirstMeaningFulPart(parsed) {\n  for (var i = 0, len = parsed.length; i < len; i++) {\n    if (parsed[i].type !== \"content\") {\n      return parsed[i];\n    }\n  }\n  return null;\n}\nfunction isInsideParagraphLoop(part) {\n  var firstMeaningfulPart = getFirstMeaningFulPart(part.subparsed);\n  return firstMeaningfulPart != null && firstMeaningfulPart.tag !== \"w:t\";\n}\nfunction getPageBreakIfApplies(part) {\n  return part.hasPageBreak && isInsideParagraphLoop(part) ? '<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>' : \"\";\n}\nfunction isEnclosedByParagraphs(parsed) {\n  return parsed.length && isParagraphStart(parsed[0]) && isParagraphEnd(last(parsed));\n}\nfunction getOffset(chunk) {\n  return hasContent(chunk) ? 0 : chunk.length;\n}\nfunction addPageBreakAtEnd(subRendered) {\n  var j = subRendered.parts.length - 1;\n  if (subRendered.parts[j] === \"</w:p>\") {\n    subRendered.parts.splice(j, 0, '<w:r><w:br w:type=\"page\"/></w:r>');\n  } else {\n    subRendered.parts.push('<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>');\n  }\n}\nfunction addPageBreakAtBeginning(subRendered) {\n  subRendered.parts.unshift('<w:p><w:r><w:br w:type=\"page\"/></w:r></w:p>');\n}\nfunction isContinuous(parts) {\n  return parts.some(function (part) {\n    return isTagStart(\"w:type\", part) && part.value.indexOf(\"continuous\") !== -1;\n  });\n}\nfunction isNextPage(parts) {\n  return parts.some(function (part) {\n    return isTagStart(\"w:type\", part) && part.value.indexOf('w:val=\"nextPage\"') !== -1;\n  });\n}\nfunction addSectionBefore(parts, sect) {\n  return [\"<w:p><w:pPr>\".concat(sect.map(function (_ref) {\n    var value = _ref.value;\n    return value;\n  }).join(\"\"), \"</w:pPr></w:p>\")].concat(parts);\n}\nfunction addContinuousType(parts) {\n  var stop = false;\n  var inSectPr = false;\n  return parts.reduce(function (result, part) {\n    if (stop === false && startsWith(part, \"<w:sectPr\")) {\n      inSectPr = true;\n    }\n    if (inSectPr) {\n      if (startsWith(part, \"<w:type\")) {\n        stop = true;\n      }\n      if (stop === false && startsWith(part, \"</w:sectPr\")) {\n        result.push('<w:type w:val=\"continuous\"/>');\n      }\n    }\n    result.push(part);\n    return result;\n  }, []);\n}\nfunction dropHeaderFooterRefs(parts) {\n  return parts.filter(function (text) {\n    return !startsWith(text, \"<w:headerReference\") && !startsWith(text, \"<w:footerReference\");\n  });\n}\nfunction hasPageBreak(chunk) {\n  return chunk.some(function (part) {\n    return part.tag === \"w:br\" && part.value.indexOf('w:type=\"page\"') !== -1;\n  });\n}\nfunction hasImage(chunk) {\n  return chunk.some(function (_ref2) {\n    var tag = _ref2.tag;\n    return tag === \"w:drawing\";\n  });\n}\nfunction getSectPr(chunks) {\n  var collectSectPr = false;\n  var sectPrs = [];\n  chunks.forEach(function (part) {\n    if (isTagStart(\"w:sectPr\", part)) {\n      sectPrs.push([]);\n      collectSectPr = true;\n    }\n    if (collectSectPr) {\n      sectPrs[sectPrs.length - 1].push(part);\n    }\n    if (isTagEnd(\"w:sectPr\", part)) {\n      collectSectPr = false;\n    }\n  });\n  return sectPrs;\n}\nfunction getSectPrHeaderFooterChangeCount(chunks) {\n  var collectSectPr = false;\n  var sectPrCount = 0;\n  chunks.forEach(function (part) {\n    if (isTagStart(\"w:sectPr\", part)) {\n      collectSectPr = true;\n    }\n    if (collectSectPr) {\n      if (part.tag === \"w:headerReference\" || part.tag === \"w:footerReference\") {\n        sectPrCount++;\n        collectSectPr = false;\n      }\n    }\n    if (isTagEnd(\"w:sectPr\", part)) {\n      collectSectPr = false;\n    }\n  });\n  return sectPrCount;\n}\nfunction getLastSectPr(parsed) {\n  var sectPr = [];\n  var inSectPr = false;\n  for (var i = parsed.length - 1; i >= 0; i--) {\n    var part = parsed[i];\n    if (isTagEnd(\"w:sectPr\", part)) {\n      inSectPr = true;\n    }\n    if (isTagStart(\"w:sectPr\", part)) {\n      sectPr.unshift(part.value);\n      inSectPr = false;\n    }\n    if (inSectPr) {\n      sectPr.unshift(part.value);\n    }\n    if (isParagraphStart(part)) {\n      if (sectPr.length > 0) {\n        return sectPr.join(\"\");\n      }\n      break;\n    }\n  }\n  return \"\";\n}\nvar LoopModule = /*#__PURE__*/function () {\n  function LoopModule() {\n    _classCallCheck(this, LoopModule);\n    this.name = \"LoopModule\";\n    this.inXfrm = false;\n    this.totalSectPr = 0;\n    this.prefix = {\n      start: \"#\",\n      end: \"/\",\n      dash: /^-([^\\s]+)\\s(.+)/,\n      inverted: \"^\"\n    };\n  }\n  _createClass(LoopModule, [{\n    key: \"optionsTransformer\",\n    value: function optionsTransformer(opts, docxtemplater) {\n      this.docxtemplater = docxtemplater;\n      return opts;\n    }\n  }, {\n    key: \"preparse\",\n    value: function preparse(parsed, _ref3) {\n      var contentType = _ref3.contentType;\n      if (filetypes.main.indexOf(contentType) !== -1) {\n        this.sects = getSectPr(parsed);\n      }\n    }\n  }, {\n    key: \"matchers\",\n    value: function matchers() {\n      var module = moduleName;\n      return [[this.prefix.start, module, {\n        expandTo: \"auto\",\n        location: \"start\",\n        inverted: false\n      }], [this.prefix.inverted, module, {\n        expandTo: \"auto\",\n        location: \"start\",\n        inverted: true\n      }], [this.prefix.end, module, {\n        location: \"end\"\n      }], [this.prefix.dash, module, function (_ref4) {\n        var _ref5 = _slicedToArray(_ref4, 3),\n          expandTo = _ref5[1],\n          value = _ref5[2];\n        return {\n          location: \"start\",\n          inverted: false,\n          expandTo: expandTo,\n          value: value\n        };\n      }]];\n    }\n  }, {\n    key: \"getTraits\",\n    value: function getTraits(traitName, parsed) {\n      // Stryker disable all : because getTraits should disappear in v4\n      if (traitName !== \"expandPair\") {\n        return;\n      }\n      // Stryker restore all\n\n      return parsed.reduce(function (tags, part, offset) {\n        if (isModule(part, moduleName) && part.subparsed == null) {\n          tags.push({\n            part: part,\n            offset: offset\n          });\n        }\n        return tags;\n      }, []);\n    }\n  }, {\n    key: \"postparse\",\n    value: function postparse(parsed, _ref6) {\n      var basePart = _ref6.basePart;\n      if (basePart && this.docxtemplater.fileType === \"docx\" && parsed.length > 0) {\n        basePart.sectPrCount = getSectPrHeaderFooterChangeCount(parsed);\n        this.totalSectPr += basePart.sectPrCount;\n        var sects = this.sects;\n        sects.some(function (sect, index) {\n          if (basePart.lIndex < sect[0].lIndex) {\n            if (index + 1 < sects.length && isContinuous(sects[index + 1])) {\n              basePart.addContinuousType = true;\n            }\n            return true;\n          }\n          if (parsed[0].lIndex < sect[0].lIndex && sect[0].lIndex < basePart.lIndex) {\n            if (isNextPage(sects[index])) {\n              basePart.addNextPage = {\n                index: index\n              };\n            }\n            return true;\n          }\n        });\n        basePart.lastParagrapSectPr = getLastSectPr(parsed);\n      }\n      if (!basePart || basePart.expandTo !== \"auto\" || basePart.module !== moduleName || !isEnclosedByParagraphs(parsed)) {\n        return parsed;\n      }\n      basePart.paragraphLoop = true;\n      var level = 0;\n      var chunks = chunkBy(parsed, function (p) {\n        if (isParagraphStart(p)) {\n          level++;\n          if (level === 1) {\n            return \"start\";\n          }\n        }\n        if (isParagraphEnd(p)) {\n          level--;\n          if (level === 0) {\n            return \"end\";\n          }\n        }\n        return null;\n      });\n      var firstChunk = chunks[0];\n      var lastChunk = last(chunks);\n      var firstOffset = getOffset(firstChunk);\n      var lastOffset = getOffset(lastChunk);\n      basePart.hasPageBreakBeginning = hasPageBreak(firstChunk);\n      basePart.hasPageBreak = hasPageBreak(lastChunk);\n      if (hasImage(firstChunk)) {\n        firstOffset = 0;\n      }\n      if (hasImage(lastChunk)) {\n        lastOffset = 0;\n      }\n      return parsed.slice(firstOffset, parsed.length - lastOffset);\n    }\n  }, {\n    key: \"resolve\",\n    value: function resolve(part, options) {\n      if (!isModule(part, moduleName)) {\n        return null;\n      }\n      var sm = options.scopeManager;\n      var promisedValue = sm.getValueAsync(part.value, {\n        part: part\n      });\n      var promises = [];\n      function loopOver(scope, i, length) {\n        var scopeManager = sm.createSubScopeManager(scope, part.value, i, part, length);\n        promises.push(options.resolve({\n          filePath: options.filePath,\n          modules: options.modules,\n          baseNullGetter: options.baseNullGetter,\n          resolve: options.resolve,\n          compiled: part.subparsed,\n          tags: {},\n          scopeManager: scopeManager\n        }));\n      }\n      var errorList = [];\n      return promisedValue.then(function (values) {\n        return new Promise(function (resolve) {\n          if (values instanceof Array) {\n            Promise.all(values).then(resolve);\n          } else {\n            resolve(values);\n          }\n        }).then(function (values) {\n          sm.loopOverValue(values, loopOver, part.inverted);\n          return Promise.all(promises).then(function (r) {\n            return r.map(function (_ref7) {\n              var resolved = _ref7.resolved,\n                errors = _ref7.errors;\n              errorList.push.apply(errorList, _toConsumableArray(errors));\n              return resolved;\n            });\n          }).then(function (value) {\n            if (errorList.length > 0) {\n              throw errorList;\n            }\n            return value;\n          });\n        });\n      });\n    }\n    // eslint-disable-next-line complexity\n  }, {\n    key: \"render\",\n    value: function render(part, options) {\n      if (part.tag === \"p:xfrm\") {\n        this.inXfrm = part.position === \"start\";\n      }\n      if (part.tag === \"a:ext\" && this.inXfrm) {\n        this.lastExt = part;\n        return part;\n      }\n      if (!isModule(part, moduleName)) {\n        return null;\n      }\n      var totalValue = [];\n      var errors = [];\n      var heightOffset = 0;\n      var self = this;\n      var firstTag = part.subparsed[0];\n      var tagHeight = 0;\n      if ((firstTag === null || firstTag === void 0 ? void 0 : firstTag.tag) === \"a:tr\") {\n        tagHeight = +getSingleAttribute(firstTag.value, \"h\");\n      }\n      heightOffset -= tagHeight;\n      var a16RowIdOffset = 0;\n      var insideParagraphLoop = isInsideParagraphLoop(part);\n\n      // eslint-disable-next-line complexity\n      function loopOver(scope, i, length) {\n        heightOffset += tagHeight;\n        var scopeManager = options.scopeManager.createSubScopeManager(scope, part.value, i, part, length);\n        part.subparsed.forEach(function (pp) {\n          if (isTagStart(\"a16:rowId\", pp)) {\n            var val = +getSingleAttribute(pp.value, \"val\") + a16RowIdOffset;\n            a16RowIdOffset = 1;\n            pp.value = setSingleAttribute(pp.value, \"val\", val);\n          }\n        });\n        var subRendered = options.render(_objectSpread(_objectSpread({}, options), {}, {\n          compiled: part.subparsed,\n          tags: {},\n          scopeManager: scopeManager\n        }));\n        if (part.hasPageBreak && i === length - 1 && insideParagraphLoop) {\n          addPageBreakAtEnd(subRendered);\n        }\n        var isNotFirst = scopeManager.scopePathItem.some(function (i) {\n          return i !== 0;\n        });\n        if (isNotFirst) {\n          if (part.sectPrCount === 1) {\n            subRendered.parts = dropHeaderFooterRefs(subRendered.parts);\n          }\n          if (part.addContinuousType) {\n            subRendered.parts = addContinuousType(subRendered.parts);\n          }\n        } else if (part.addNextPage) {\n          subRendered.parts = addSectionBefore(subRendered.parts, self.sects[part.addNextPage.index]);\n        }\n        if (part.addNextPage) {\n          addPageBreakAtEnd(subRendered);\n        }\n        if (part.hasPageBreakBeginning && insideParagraphLoop) {\n          addPageBreakAtBeginning(subRendered);\n        }\n        for (var _i2 = 0, len = subRendered.parts.length; _i2 < len; _i2++) {\n          totalValue.push(subRendered.parts[_i2]);\n        }\n        Array.prototype.push.apply(errors, subRendered.errors);\n      }\n      var result = options.scopeManager.loopOver(part.value, loopOver, part.inverted, {\n        part: part\n      });\n      // if the loop is showing empty content\n      if (result === false) {\n        if (part.lastParagrapSectPr) {\n          if (part.paragraphLoop) {\n            return {\n              value: \"<w:p><w:pPr>\".concat(part.lastParagrapSectPr, \"</w:pPr></w:p>\")\n            };\n          }\n          return {\n            value: \"</w:t></w:r></w:p><w:p><w:pPr>\".concat(part.lastParagrapSectPr, \"</w:pPr><w:r><w:t>\")\n          };\n        }\n        return {\n          value: getPageBreakIfApplies(part) || \"\",\n          errors: errors\n        };\n      }\n      if (heightOffset !== 0) {\n        var cy = +getSingleAttribute(this.lastExt.value, \"cy\");\n        this.lastExt.value = setSingleAttribute(this.lastExt.value, \"cy\", cy + heightOffset);\n      }\n      return {\n        value: options.joinUncorrupt(totalValue, _objectSpread(_objectSpread({}, options), {}, {\n          basePart: part\n        })),\n        errors: errors\n      };\n    }\n  }]);\n  return LoopModule;\n}();\nmodule.exports = function () {\n  return wrapper(new LoopModule());\n};","\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar wrapper = require(\"../module-wrapper.js\");\nvar _require = require(\"../doc-utils.js\"),\n  isTextStart = _require.isTextStart,\n  isTextEnd = _require.isTextEnd,\n  endsWith = _require.endsWith,\n  startsWith = _require.startsWith;\nvar wTpreserve = '<w:t xml:space=\"preserve\">';\nvar wTpreservelen = wTpreserve.length;\nvar wtEnd = \"</w:t>\";\nvar wtEndlen = wtEnd.length;\nfunction isWtStart(part) {\n  return isTextStart(part) && part.tag === \"w:t\";\n}\nfunction addXMLPreserve(chunk, index) {\n  var tag = chunk[index].value;\n  if (chunk[index + 1].value === \"</w:t>\") {\n    return tag;\n  }\n  if (tag.indexOf('xml:space=\"preserve\"') !== -1) {\n    return tag;\n  }\n  return tag.substr(0, tag.length - 1) + ' xml:space=\"preserve\">';\n}\nfunction isInsideLoop(meta, chunk) {\n  return meta && meta.basePart && chunk.length > 1;\n}\nvar SpacePreserve = /*#__PURE__*/function () {\n  function SpacePreserve() {\n    _classCallCheck(this, SpacePreserve);\n    this.name = \"SpacePreserveModule\";\n  }\n  _createClass(SpacePreserve, [{\n    key: \"clone\",\n    value: function clone() {\n      return new SpacePreserve();\n    }\n  }, {\n    key: \"postparse\",\n    value: function postparse(postparsed, meta) {\n      var chunk = [],\n        inTextTag = false,\n        endLindex = 0,\n        lastTextTag = 0;\n      function isStartingPlaceHolder(part, chunk) {\n        return part.type === \"placeholder\" && chunk.length > 1;\n      }\n      var result = postparsed.reduce(function (postparsed, part) {\n        if (isWtStart(part)) {\n          inTextTag = true;\n          lastTextTag = chunk.length;\n        }\n        if (!inTextTag) {\n          postparsed.push(part);\n          return postparsed;\n        }\n        chunk.push(part);\n        if (isInsideLoop(meta, chunk)) {\n          endLindex = meta.basePart.endLindex;\n          chunk[0].value = addXMLPreserve(chunk, 0);\n        }\n        if (isStartingPlaceHolder(part, chunk)) {\n          chunk[lastTextTag].value = addXMLPreserve(chunk, lastTextTag);\n          endLindex = part.endLindex;\n        }\n        if (isTextEnd(part) && part.lIndex > endLindex) {\n          if (endLindex !== 0) {\n            chunk[lastTextTag].value = addXMLPreserve(chunk, lastTextTag);\n          }\n          Array.prototype.push.apply(postparsed, chunk);\n          chunk = [];\n          inTextTag = false;\n          endLindex = 0;\n          lastTextTag = 0;\n        }\n        return postparsed;\n      }, []);\n      Array.prototype.push.apply(result, chunk);\n      return result;\n    }\n  }, {\n    key: \"postrender\",\n    value: function postrender(parts) {\n      var lastNonEmpty = \"\";\n      var lastNonEmptyIndex = 0;\n      for (var i = 0, len = parts.length; i < len; i++) {\n        var index = i;\n        var p = parts[i];\n        if (p === \"\") {\n          continue;\n        }\n        if (endsWith(lastNonEmpty, wTpreserve) && startsWith(p, wtEnd)) {\n          parts[lastNonEmptyIndex] = lastNonEmpty.substr(0, lastNonEmpty.length - wTpreservelen) + \"<w:t/>\";\n          p = p.substr(wtEndlen);\n        }\n        lastNonEmpty = p;\n        lastNonEmptyIndex = index;\n        parts[i] = p;\n      }\n      return parts;\n    }\n  }]);\n  return SpacePreserve;\n}();\nmodule.exports = function () {\n  return wrapper(new SpacePreserve());\n};","\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar traits = require(\"../traits.js\");\nvar _require = require(\"../doc-utils.js\"),\n  isContent = _require.isContent;\nvar _require2 = require(\"../errors.js\"),\n  throwRawTagShouldBeOnlyTextInParagraph = _require2.throwRawTagShouldBeOnlyTextInParagraph,\n  getInvalidRawXMLValueException = _require2.getInvalidRawXMLValueException;\nvar moduleName = \"rawxml\";\nvar wrapper = require(\"../module-wrapper.js\");\nfunction getInner(_ref) {\n  var part = _ref.part,\n    left = _ref.left,\n    right = _ref.right,\n    postparsed = _ref.postparsed,\n    index = _ref.index;\n  var paragraphParts = postparsed.slice(left + 1, right);\n  paragraphParts.forEach(function (p, i) {\n    if (i === index - left - 1) {\n      return;\n    }\n    if (isContent(p)) {\n      throwRawTagShouldBeOnlyTextInParagraph({\n        paragraphParts: paragraphParts,\n        part: part\n      });\n    }\n  });\n  return part;\n}\nvar RawXmlModule = /*#__PURE__*/function () {\n  function RawXmlModule() {\n    _classCallCheck(this, RawXmlModule);\n    this.name = \"RawXmlModule\";\n    this.prefix = \"@\";\n  }\n  _createClass(RawXmlModule, [{\n    key: \"optionsTransformer\",\n    value: function optionsTransformer(options, docxtemplater) {\n      this.fileTypeConfig = docxtemplater.fileTypeConfig;\n      return options;\n    }\n  }, {\n    key: \"matchers\",\n    value: function matchers() {\n      return [[this.prefix, moduleName]];\n    }\n  }, {\n    key: \"postparse\",\n    value: function postparse(postparsed) {\n      return traits.expandToOne(postparsed, {\n        moduleName: moduleName,\n        getInner: getInner,\n        expandTo: this.fileTypeConfig.tagRawXml,\n        error: {\n          message: \"Raw tag not in paragraph\",\n          id: \"raw_tag_outerxml_invalid\",\n          explanation: function explanation(part) {\n            return \"The tag \\\"\".concat(part.value, \"\\\" is not inside a paragraph, putting raw tags inside an inline loop is disallowed.\");\n          }\n        }\n      });\n    }\n  }, {\n    key: \"render\",\n    value: function render(part, options) {\n      if (part.module !== moduleName) {\n        return null;\n      }\n      var value;\n      var errors = [];\n      try {\n        value = options.scopeManager.getValue(part.value, {\n          part: part\n        });\n        if (value == null) {\n          value = options.nullGetter(part);\n        }\n      } catch (e) {\n        errors.push(e);\n        return {\n          errors: errors\n        };\n      }\n      value = value ? value : \"\";\n      if (typeof value === \"string\") {\n        return {\n          value: value\n        };\n      }\n      return {\n        errors: [getInvalidRawXMLValueException({\n          tag: part.value,\n          value: value,\n          offset: part.offset\n        })]\n      };\n    }\n  }]);\n  return RawXmlModule;\n}();\nmodule.exports = function () {\n  return wrapper(new RawXmlModule());\n};","\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar traitName = \"expandPair\";\nvar mergeSort = require(\"../merge-sort.js\");\nvar _require = require(\"../doc-utils.js\"),\n  getLeft = _require.getLeft,\n  getRight = _require.getRight;\nvar wrapper = require(\"../module-wrapper.js\");\nvar _require2 = require(\"../traits.js\"),\n  getExpandToDefault = _require2.getExpandToDefault;\nvar _require3 = require(\"../errors.js\"),\n  getUnmatchedLoopException = _require3.getUnmatchedLoopException,\n  getClosingTagNotMatchOpeningTag = _require3.getClosingTagNotMatchOpeningTag,\n  getUnbalancedLoopException = _require3.getUnbalancedLoopException;\nfunction getOpenCountChange(part) {\n  switch (part.location) {\n    case \"start\":\n      return 1;\n    case \"end\":\n      return -1;\n  }\n}\nfunction match(start, end) {\n  return start != null && end != null && (start.part.location === \"start\" && end.part.location === \"end\" && start.part.value === end.part.value || end.part.value === \"\");\n}\nfunction transformer(traits) {\n  var i = 0;\n  var errors = [];\n  while (i < traits.length) {\n    var part = traits[i].part;\n    if (part.location === \"end\") {\n      if (i === 0) {\n        traits.splice(0, 1);\n        errors.push(getUnmatchedLoopException(part));\n        return {\n          traits: traits,\n          errors: errors\n        };\n      }\n      var endIndex = i;\n      var startIndex = i - 1;\n      var offseter = 1;\n      if (match(traits[startIndex], traits[endIndex])) {\n        traits.splice(endIndex, 1);\n        traits.splice(startIndex, 1);\n        return {\n          errors: errors,\n          traits: traits\n        };\n      }\n      while (offseter < 50) {\n        var startCandidate = traits[startIndex - offseter];\n        var endCandidate = traits[endIndex + offseter];\n        if (match(startCandidate, traits[endIndex])) {\n          traits.splice(endIndex, 1);\n          traits.splice(startIndex - offseter, 1);\n          return {\n            errors: errors,\n            traits: traits\n          };\n        }\n        if (match(traits[startIndex], endCandidate)) {\n          traits.splice(endIndex + offseter, 1);\n          traits.splice(startIndex, 1);\n          return {\n            errors: errors,\n            traits: traits\n          };\n        }\n        offseter++;\n      }\n      errors.push(getClosingTagNotMatchOpeningTag({\n        tags: [traits[startIndex].part, traits[endIndex].part]\n      }));\n      traits.splice(endIndex, 1);\n      traits.splice(startIndex, 1);\n      return {\n        traits: traits,\n        errors: errors\n      };\n    }\n    i++;\n  }\n  traits.forEach(function (_ref) {\n    var part = _ref.part;\n    errors.push(getUnmatchedLoopException(part));\n  });\n  return {\n    traits: [],\n    errors: errors\n  };\n}\nfunction getPairs(traits) {\n  var levelTraits = {};\n  var errors = [];\n  var pairs = [];\n  var transformedTraits = [];\n  for (var i = 0; i < traits.length; i++) {\n    transformedTraits.push(traits[i]);\n  }\n  while (transformedTraits.length > 0) {\n    var result = transformer(transformedTraits);\n    errors = errors.concat(result.errors);\n    transformedTraits = result.traits;\n  }\n\n  // Stryker disable all : because this check makes the function return quicker\n  if (errors.length > 0) {\n    return {\n      pairs: pairs,\n      errors: errors\n    };\n  }\n  // Stryker restore all\n  var countOpen = 0;\n  for (var _i = 0; _i < traits.length; _i++) {\n    var currentTrait = traits[_i];\n    var part = currentTrait.part;\n    var change = getOpenCountChange(part);\n    countOpen += change;\n    if (change === 1) {\n      levelTraits[countOpen] = currentTrait;\n    } else {\n      var startTrait = levelTraits[countOpen + 1];\n      if (countOpen === 0) {\n        pairs = pairs.concat([[startTrait, currentTrait]]);\n      }\n    }\n    countOpen = countOpen >= 0 ? countOpen : 0;\n  }\n  return {\n    pairs: pairs,\n    errors: errors\n  };\n}\nvar ExpandPairTrait = /*#__PURE__*/function () {\n  function ExpandPairTrait() {\n    _classCallCheck(this, ExpandPairTrait);\n    this.name = \"ExpandPairTrait\";\n  }\n  _createClass(ExpandPairTrait, [{\n    key: \"clone\",\n    value: function clone() {\n      return new ExpandPairTrait();\n    }\n  }, {\n    key: \"optionsTransformer\",\n    value: function optionsTransformer(options, docxtemplater) {\n      this.expandTags = docxtemplater.fileTypeConfig.expandTags.concat(docxtemplater.options.paragraphLoop ? docxtemplater.fileTypeConfig.onParagraphLoop : []);\n      return options;\n    }\n  }, {\n    key: \"postparse\",\n    value: function postparse(postparsed, _ref2) {\n      var _this = this;\n      var getTraits = _ref2.getTraits,\n        _postparse = _ref2.postparse;\n      var traits = getTraits(traitName, postparsed);\n      traits = traits.map(function (trait) {\n        return trait || [];\n      });\n      traits = mergeSort(traits);\n      var _getPairs = getPairs(traits),\n        pairs = _getPairs.pairs,\n        errors = _getPairs.errors;\n      var lastRight = 0;\n      var lastPair = null;\n      var expandedPairs = pairs.map(function (pair) {\n        var expandTo = pair[0].part.expandTo;\n        if (expandTo === \"auto\") {\n          var result = getExpandToDefault(postparsed, pair, _this.expandTags);\n          if (result.error) {\n            errors.push(result.error);\n          }\n          expandTo = result.value;\n        }\n        if (!expandTo) {\n          var _left = pair[0].offset;\n          var _right = pair[1].offset;\n          if (_left < lastRight) {\n            errors.push(getUnbalancedLoopException(pair, lastPair));\n          }\n          lastPair = pair;\n          lastRight = _right;\n          return [_left, _right];\n        }\n        var left, right;\n        try {\n          left = getLeft(postparsed, expandTo, pair[0].offset);\n        } catch (e) {\n          errors.push(e);\n        }\n        try {\n          right = getRight(postparsed, expandTo, pair[1].offset);\n        } catch (e) {\n          errors.push(e);\n        }\n        if (left < lastRight) {\n          errors.push(getUnbalancedLoopException(pair, lastPair));\n        }\n        lastRight = right;\n        lastPair = pair;\n        return [left, right];\n      });\n\n      // Stryker disable all : because this check makes the function return quicker\n      if (errors.length > 0) {\n        return {\n          postparsed: postparsed,\n          errors: errors\n        };\n      }\n      // Stryker restore all\n\n      var currentPairIndex = 0;\n      var innerParts;\n      var newParsed = postparsed.reduce(function (newParsed, part, i) {\n        var inPair = currentPairIndex < pairs.length && expandedPairs[currentPairIndex][0] <= i && i <= expandedPairs[currentPairIndex][1];\n        var pair = pairs[currentPairIndex];\n        var expandedPair = expandedPairs[currentPairIndex];\n        if (!inPair) {\n          newParsed.push(part);\n          return newParsed;\n        }\n        if (expandedPair[0] === i) {\n          innerParts = [];\n        }\n        if (pair[0].offset !== i && pair[1].offset !== i) {\n          innerParts.push(part);\n        }\n        if (expandedPair[1] === i) {\n          var basePart = postparsed[pair[0].offset];\n          basePart.subparsed = _postparse(innerParts, {\n            basePart: basePart\n          });\n          basePart.endLindex = pair[1].part.lIndex;\n          delete basePart.location;\n          delete basePart.expandTo;\n          newParsed.push(basePart);\n          currentPairIndex++;\n        }\n        return newParsed;\n      }, []);\n      return {\n        postparsed: newParsed,\n        errors: errors\n      };\n    }\n  }]);\n  return ExpandPairTrait;\n}();\nmodule.exports = function () {\n  return wrapper(new ExpandPairTrait());\n};","\n\nfunction getMinFromArrays(arrays, state) {\n  var minIndex = -1;\n  for (var i = 0, l = arrays.length; i < l; i++) {\n    if (state[i] >= arrays[i].length) {\n      continue;\n    }\n    if (minIndex === -1 || arrays[i][state[i]].offset < arrays[minIndex][state[minIndex]].offset) {\n      minIndex = i;\n    }\n  }\n  return minIndex;\n}\nmodule.exports = function (arrays) {\n  var totalLength = arrays.reduce(function (sum, array) {\n    return sum + array.length;\n  }, 0);\n  arrays = arrays.filter(function (array) {\n    return array.length > 0;\n  });\n  var resultArray = new Array(totalLength);\n  var state = arrays.map(function () {\n    return 0;\n  });\n  for (var i = 0; i < totalLength; i++) {\n    var arrayIndex = getMinFromArrays(arrays, state);\n    resultArray[i] = arrays[arrayIndex][state[arrayIndex]];\n    state[arrayIndex]++;\n  }\n  return resultArray;\n};","\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nvar wrapper = require(\"../module-wrapper.js\");\nvar _require = require(\"../errors.js\"),\n  getScopeCompilationError = _require.getScopeCompilationError;\nvar _require2 = require(\"../doc-utils.js\"),\n  utf8ToWord = _require2.utf8ToWord,\n  hasCorruptCharacters = _require2.hasCorruptCharacters;\nvar _require3 = require(\"../errors.js\"),\n  getCorruptCharactersException = _require3.getCorruptCharactersException;\nvar ftprefix = {\n  docx: \"w\",\n  pptx: \"a\"\n};\nvar Render = /*#__PURE__*/function () {\n  function Render() {\n    _classCallCheck(this, Render);\n    this.name = \"Render\";\n    this.recordRun = false;\n    this.recordedRun = [];\n  }\n  _createClass(Render, [{\n    key: \"optionsTransformer\",\n    value: function optionsTransformer(options, docxtemplater) {\n      this.parser = docxtemplater.parser;\n      this.fileType = docxtemplater.fileType;\n      return options;\n    }\n  }, {\n    key: \"set\",\n    value: function set(obj) {\n      if (obj.compiled) {\n        this.compiled = obj.compiled;\n      }\n      if (obj.data != null) {\n        this.data = obj.data;\n      }\n    }\n  }, {\n    key: \"getRenderedMap\",\n    value: function getRenderedMap(mapper) {\n      var _this = this;\n      return Object.keys(this.compiled).reduce(function (mapper, from) {\n        mapper[from] = {\n          from: from,\n          data: _this.data\n        };\n        return mapper;\n      }, mapper);\n    }\n  }, {\n    key: \"postparse\",\n    value: function postparse(postparsed, options) {\n      var _this2 = this;\n      var errors = [];\n      postparsed.forEach(function (p) {\n        if (p.type === \"placeholder\") {\n          var tag = p.value;\n          try {\n            options.cachedParsers[p.lIndex] = _this2.parser(tag, {\n              tag: p\n            });\n          } catch (rootError) {\n            errors.push(getScopeCompilationError({\n              tag: tag,\n              rootError: rootError,\n              offset: p.offset\n            }));\n          }\n        }\n      });\n      return {\n        postparsed: postparsed,\n        errors: errors\n      };\n    }\n  }, {\n    key: \"render\",\n    value: function render(part, _ref) {\n      var scopeManager = _ref.scopeManager,\n        linebreaks = _ref.linebreaks,\n        nullGetter = _ref.nullGetter;\n      if (linebreaks) {\n        this.recordRuns(part);\n      }\n      if (part.type !== \"placeholder\" || part.module) {\n        return;\n      }\n      var value;\n      try {\n        value = scopeManager.getValue(part.value, {\n          part: part\n        });\n      } catch (e) {\n        return {\n          errors: [e]\n        };\n      }\n      if (value == null) {\n        value = nullGetter(part);\n      }\n      if (hasCorruptCharacters(value)) {\n        return {\n          errors: [getCorruptCharactersException({\n            tag: part.value,\n            value: value,\n            offset: part.offset\n          })]\n        };\n      }\n      return {\n        value: linebreaks && typeof value === \"string\" ? this.renderLineBreaks(value) : utf8ToWord(value)\n      };\n    }\n  }, {\n    key: \"recordRuns\",\n    value: function recordRuns(part) {\n      if (part.tag === \"\".concat(ftprefix[this.fileType], \":r\")) {\n        this.recordedRun = [];\n      } else if (part.tag === \"\".concat(ftprefix[this.fileType], \":rPr\")) {\n        if (part.position === \"start\") {\n          this.recordRun = true;\n          this.recordedRun = [part.value];\n        }\n        if (part.position === \"end\" || part.position === \"selfclosing\") {\n          this.recordedRun.push(part.value);\n          this.recordRun = false;\n        }\n      } else if (this.recordRun) {\n        this.recordedRun.push(part.value);\n      }\n    }\n  }, {\n    key: \"renderLineBreaks\",\n    value: function renderLineBreaks(value) {\n      var _this3 = this;\n      var p = ftprefix[this.fileType];\n      var br = this.fileType === \"docx\" ? \"<w:r><w:br/></w:r>\" : \"<a:br/>\";\n      var lines = value.split(\"\\n\");\n      var runprops = this.recordedRun.join(\"\");\n      return lines.map(function (line) {\n        return utf8ToWord(line);\n      }).reduce(function (result, line, i) {\n        result.push(line);\n        if (i < lines.length - 1) {\n          result.push(\"</\".concat(p, \":t></\").concat(p, \":r>\").concat(br, \"<\").concat(p, \":r>\").concat(runprops, \"<\").concat(p, \":t\").concat(_this3.fileType === \"docx\" ? ' xml:space=\"preserve\"' : \"\", \">\"));\n        }\n        return result;\n      }, []);\n    }\n  }]);\n  return Render;\n}();\nmodule.exports = function () {\n  return wrapper(new Render());\n};"]}